{
  "version": 3,
  "sources": ["../../fast-deep-equal/index.js", "../../@react-three/rapier/dist/react-three-rapier.esm.js", "../../use-asset/dist/index.js"],
  "sourcesContent": ["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "import { ColliderDesc, ActiveEvents, RigidBodyDesc, EventQueue } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useMemo, useEffect, useContext, useState, memo, createContext, useCallback, forwardRef, useImperativeHandle, useLayoutEffect } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, MathUtils, InstancedMesh, BufferAttribute, DynamicDrawUsage } from 'three';\nimport { useAsset } from 'use-asset';\nimport { mergeVertices, VertexNormalsHelper } from 'three-stdlib';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nconst _object3d = new Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst tupleToObject = (tuple, keys) => {\n  return keys.reduce((obj, key, i) => {\n    obj[key] = tuple[i];\n    return obj;\n  }, {});\n};\nconst rapierVector3ToVector3 = ({\n  x,\n  y,\n  z\n}) => _vector3.set(x, y, z);\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n\n  if (Array.isArray(v)) {\n    return v;\n  }\n\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef();\n\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n\n  return ref.current.value;\n}\n\nconst createRigidBodyApi = ref => {\n  return {\n    raw: () => ref.current(),\n\n    get handle() {\n      return ref.current().handle;\n    },\n\n    mass: () => ref.current().mass(),\n\n    applyImpulse(impulseVector, wakeUp = true) {\n      ref.current().applyImpulse(impulseVector, wakeUp);\n    },\n\n    applyTorqueImpulse(torqueVector, wakeUp = true) {\n      ref.current().applyTorqueImpulse(torqueVector, wakeUp);\n    },\n\n    applyImpulseAtPoint: (impulseVector, impulsePoint, wakeUp = true) => ref.current().applyImpulseAtPoint(impulseVector, impulsePoint, wakeUp),\n    addForce: (force, wakeUp = true) => ref.current().addForce(force, wakeUp),\n    addForceAtPoint: (force, point, wakeUp = true) => ref.current().addForceAtPoint(force, point, wakeUp),\n    addTorque: (torque, wakeUp = true) => ref.current().addTorque(torque, wakeUp),\n\n    translation() {\n      return rapierVector3ToVector3(ref.current().translation());\n    },\n\n    setTranslation: (translation, wakeUp = true) => ref.current().setTranslation(translation, wakeUp),\n\n    rotation() {\n      const {\n        x,\n        y,\n        z,\n        w\n      } = ref.current().rotation();\n      return new Quaternion(x, y, z, w);\n    },\n\n    setRotation: (rotation, wakeUp = true) => {\n      ref.current().setRotation(rotation, wakeUp);\n    },\n\n    linvel() {\n      const {\n        x,\n        y,\n        z\n      } = ref.current().linvel();\n      return new Vector3(x, y, z);\n    },\n\n    setLinvel: (velocity, wakeUp = true) => ref.current().setLinvel(velocity, wakeUp),\n\n    angvel() {\n      const {\n        x,\n        y,\n        z\n      } = ref.current().angvel();\n      return new Vector3(x, y, z);\n    },\n\n    setAngvel: (velocity, wakeUp = true) => ref.current().setAngvel(velocity, wakeUp),\n\n    linearDamping() {\n      return ref.current().linearDamping();\n    },\n\n    setLinearDamping: factor => ref.current().setLinearDamping(factor),\n\n    angularDamping() {\n      return ref.current().angularDamping();\n    },\n\n    setAngularDamping: factor => ref.current().setAngularDamping(factor),\n    setNextKinematicRotation: rotation => {\n      ref.current().setNextKinematicRotation(rotation);\n    },\n    setNextKinematicTranslation: translation => ref.current().setNextKinematicTranslation(translation),\n    resetForces: (wakeUp = true) => ref.current().resetForces(wakeUp),\n    resetTorques: (wakeUp = true) => ref.current().resetTorques(wakeUp),\n    lockRotations: (locked, wakeUp = true) => ref.current().lockRotations(locked, wakeUp),\n    lockTranslations: (locked, wakeUp = true) => ref.current().lockTranslations(locked, wakeUp),\n    setEnabledRotations: (x, y, z, wakeUp = true) => ref.current().setEnabledRotations(x, y, z, wakeUp),\n    setEnabledTranslations: (x, y, z, wakeUp = true) => ref.current().setEnabledTranslations(x, y, z, wakeUp)\n  };\n};\nconst createInstancedRigidBodiesApi = bodiesGetter => ({\n  at: index => bodiesGetter.current()[index].api,\n\n  forEach(callback) {\n    return bodiesGetter.current().map(b => b.api).forEach(callback);\n  },\n\n  get count() {\n    return bodiesGetter.current().length;\n  }\n\n});\nconst createWorldApi = ref => {\n  return {\n    raw: () => ref.current(),\n    getCollider: handle => ref.current().getCollider(handle),\n    getRigidBody: handle => ref.current().getRigidBody(handle),\n    createRigidBody: desc => ref.current().createRigidBody(desc),\n    createCollider: (desc, rigidBody) => ref.current().createCollider(desc, rigidBody),\n    removeRigidBody: rigidBody => {\n      if (!ref.current().bodies.contains(rigidBody.handle)) return;\n      ref.current().removeRigidBody(rigidBody);\n    },\n    removeCollider: (collider, wakeUp = true) => {\n      if (!ref.current().colliders.contains(collider.handle)) return;\n      ref.current().removeCollider(collider, wakeUp);\n    },\n    createImpulseJoint: (params, rigidBodyA, rigidBodyB, wakeUp = true) => ref.current().createImpulseJoint(params, rigidBodyA, rigidBodyB, wakeUp),\n    removeImpulseJoint: (joint, wakeUp = true) => {\n      if (!ref.current().impulseJoints.contains(joint.handle)) return;\n      ref.current().removeImpulseJoint(joint, wakeUp);\n    },\n    forEachCollider: callback => ref.current().forEachCollider(callback),\n    setGravity: ({\n      x,\n      y,\n      z\n    }) => ref.current().gravity = {\n      x,\n      y,\n      z\n    },\n    debugRender: () => ref.current().debugRender()\n  };\n};\nconst createJointApi = ref => {\n  return {\n    raw: () => ref.current(),\n\n    get handle() {\n      return ref.current().handle;\n    },\n\n    configureMotorPosition: (targetPos, stiffness, damping) => ref.current().configureMotorPosition(targetPos, stiffness, damping),\n    configureMotorVelocity: (targetVel, damping) => ref.current().configureMotorVelocity(targetVel, damping)\n  };\n};\n\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice(); // Heightfield uses a vector\n\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  } // Trimesh and convex scale the vertices\n\n\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  } // Prepfill with some extra\n\n\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, rigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, rigidBody);\n};\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\n\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setDensity(options.density);\n    return;\n  }\n\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setMass(options.mass);\n    return;\n  }\n\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\n\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  // To make sure the options all mutalbe options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n\n  if (state) {\n    var _state$worldParent;\n\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n\n    _matrix4.copy(state.object.matrixWorld);\n\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n\n    _matrix4.decompose(_position, _rotation, _scale);\n\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider, // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    }); // handle mass separately, because the assignments\n    // are exclusive.\n\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (collidersRef, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    collidersRef.current.forEach(collider => {\n      setColliderOptions(collider, props, states);\n    });\n  }, mutablePropsAsFlatArray);\n};\n\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\n\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const colliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      colliderProps.push(_objectSpread2(_objectSpread2({}, options), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      }));\n    }\n  };\n\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n\n  return colliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst useColliderEvents = (collidersRef, props, events) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    var _collidersRef$current;\n\n    (_collidersRef$current = collidersRef.current) === null || _collidersRef$current === void 0 ? void 0 : _collidersRef$current.forEach(collider => {\n      const hasCollisionEvent = !!(onCollisionEnter || onCollisionExit || onIntersectionEnter || onIntersectionExit);\n      const hasContactForceEvent = !!onContactForce;\n\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    });\n    return () => {\n      var _collidersRef$current2;\n\n      (_collidersRef$current2 = collidersRef.current) === null || _collidersRef$current2 === void 0 ? void 0 : _collidersRef$current2.forEach(collider => events.delete(collider.handle));\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type); // Apply immutable options\n\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false\n  };\n};\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value));\n  },\n\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n\n  const state = states.get(rigidBody.handle);\n\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (rigidBodyRef, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    if (Array.isArray(rigidBodyRef.current)) {\n      for (const rigidBody of rigidBodyRef.current) {\n        setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n      }\n    } else if (rigidBodyRef.current) {\n      setRigidBodyOptions(rigidBodyRef.current, props, states, updateTranslations);\n    }\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (rigidBodyRef, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit\n  };\n  useEffect(() => {\n    if (Array.isArray(rigidBodyRef.current)) {\n      for (const rigidBody of rigidBodyRef.current) {\n        events.set(rigidBody.handle, eventHandlers);\n      }\n    } else if (rigidBodyRef.current) {\n      events.set(rigidBodyRef.current.handle, eventHandlers);\n    }\n\n    return () => {\n      if (Array.isArray(rigidBodyRef.current)) {\n        for (const rigidBody of rigidBodyRef.current) {\n          events.delete(rigidBody.handle);\n        }\n      } else if (rigidBodyRef.current) {\n        events.delete(rigidBodyRef.current.handle);\n      }\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit]);\n};\n\nconst useRapier = () => {\n  return useContext(rapierContext);\n};\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  useEffect(() => {\n    beforeStepCallbacks.add(callback);\n    return () => {\n      beforeStepCallbacks.delete(callback);\n    };\n  }, []);\n};\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  useEffect(() => {\n    afterStepCallbacks.add(callback);\n    return () => {\n      afterStepCallbacks.delete(callback);\n    };\n  }, []);\n}; // Internal hooks\n\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\nconst useRigidBody = (options = {}) => {\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const ref = useRef();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(ref, mergedOptions); // Create rigidbody\n\n  const rigidBodyRef = useRef();\n  const getRigidBodyRef = useRef(() => {\n    if (!rigidBodyRef.current) {\n      const desc = rigidBodyDescFromOptions(options);\n      const rigidBody = world.createRigidBody(desc);\n      rigidBodyRef.current = world.getRigidBody(rigidBody.handle);\n    }\n\n    return rigidBodyRef.current;\n  }); // Setup\n\n  useEffect(() => {\n    const rigidBody = getRigidBodyRef.current();\n    rigidBodyRef.current = rigidBody;\n\n    if (!ref.current) {\n      ref.current = new Object3D();\n    }\n\n    rigidBodyStates.set(rigidBody.handle, createRigidBodyState({\n      rigidBody,\n      object: ref.current\n    }));\n    return () => {\n      world.removeRigidBody(rigidBody);\n      rigidBodyStates.delete(rigidBody.handle);\n      rigidBodyRef.current = undefined;\n    };\n  }, []);\n  useUpdateRigidBodyOptions(rigidBodyRef, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(rigidBodyRef, mergedOptions, rigidBodyEvents);\n  const api = useMemo(() => createRigidBodyApi(getRigidBodyRef), []);\n  return [ref, api, childColliderProps];\n};\n\nconst calcForceByType = {\n  static: (s, m2, r, d, G) => s,\n  linear: (s, m2, r, d, G) => s * (d / r),\n  newtonian: (s, m2, r, d, G) => G * s * m2 / Math.pow(d, 2)\n};\nconst applyAttractorForceOnRigidBody = (rigidBody, {\n  object,\n  strength,\n  range,\n  gravitationalConstant,\n  collisionGroups,\n  type\n}) => {\n  const rbPosition = rigidBody.translation();\n\n  _position.set(rbPosition.x, rbPosition.y, rbPosition.z);\n\n  const worldPosition = object.getWorldPosition(new Vector3());\n  const distance = worldPosition.distanceTo(_position);\n\n  if (distance < range) {\n    let force = calcForceByType[type](strength, rigidBody.mass(), range, distance, gravitationalConstant); // Prevent wild forces when Attractors collide\n\n    force = force === Infinity ? strength : force; // Naively test if the rigidBody contains a collider in one of the collision groups\n\n    let isRigidBodyInCollisionGroup = collisionGroups === undefined ? true : false;\n\n    if (collisionGroups !== undefined) {\n      for (let i = 0; i < rigidBody.numColliders(); i++) {\n        const collider = rigidBody.collider(i);\n        const colliderCollisionGroups = collider.collisionGroups();\n\n        if ((collisionGroups >> 16 & colliderCollisionGroups) != 0 && (colliderCollisionGroups >> 16 & collisionGroups) != 0) {\n          isRigidBodyInCollisionGroup = true;\n          break;\n        }\n      }\n    }\n\n    if (isRigidBodyInCollisionGroup) {\n      _vector3.set(0, 0, 0).subVectors(worldPosition, _position).normalize().multiplyScalar(force);\n\n      rigidBody.applyImpulse(_vector3, true);\n    }\n  }\n};\nconst Attractor = /*#__PURE__*/memo(props => {\n  const {\n    position = [0, 0, 0],\n    strength = 1,\n    range = 10,\n    type = \"static\",\n    gravitationalConstant = 6.673e-11,\n    collisionGroups\n  } = props;\n  const {\n    attractorStates\n  } = useRapier();\n  const object = useRef(null);\n  useEffect(() => {\n    var _object$current;\n\n    let uuid = ((_object$current = object.current) === null || _object$current === void 0 ? void 0 : _object$current.uuid) || \"_\";\n\n    if (object.current) {\n      attractorStates.set(uuid, {\n        object: object.current,\n        strength,\n        range,\n        type,\n        gravitationalConstant,\n        collisionGroups\n      });\n    }\n\n    return () => {\n      attractorStates.delete(uuid);\n    };\n  }, [props]);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    position: position\n  });\n});\n\nconst rapierContext = /*#__PURE__*/createContext(undefined);\n\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\n\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n\nconst Physics = ({\n  colliders: _colliders = \"cuboid\",\n  gravity: _gravity = [0, -9.81, 0],\n  children,\n  timeStep: _timeStep = 1 / 60,\n  paused: _paused = false,\n  updatePriority,\n  interpolate: _interpolate = true\n}) => {\n  const rapier = useAsset(importRapier);\n  const worldRef = useRef();\n  const getWorldRef = useRef(() => {\n    if (!worldRef.current) {\n      const world = new rapier.World(vectorArrayToVector3(_gravity));\n      worldRef.current = world;\n    }\n\n    return worldRef.current;\n  });\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const attractorStates = useConst(() => new Map());\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set()); // Init world\n\n  useEffect(() => {\n    const world = getWorldRef.current();\n    return () => {\n      if (world) {\n        world.free();\n        worldRef.current = undefined;\n      }\n    };\n  }, []); // Update gravity\n\n  useEffect(() => {\n    const world = worldRef.current;\n\n    if (world) {\n      world.gravity = vectorArrayToVector3(_gravity);\n    }\n  }, [_gravity]);\n  const api = useMemo(() => createWorldApi(getWorldRef), []);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    const world = worldRef.current;\n\n    if (world) {\n      var _collider$parent;\n\n      const collider = world.getCollider(handle);\n      const colEvents = colliderEvents.get(handle);\n      const colliderState = colliderStates.get(handle);\n      const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n      const rigidBody = rigidBodyHandle !== undefined ? world.getRigidBody(rigidBodyHandle) : undefined;\n      const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n      const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n      const source = {\n        collider: {\n          object: collider,\n          events: colEvents,\n          state: colliderState\n        },\n        rigidBody: {\n          object: rigidBody,\n          events: rbEvents,\n          state: rigidBodyState\n        }\n      };\n      return source;\n    }\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldRef.current;\n    if (!world) return;\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n\n    const timeStepVariable = _timeStep === \"vary\";\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.2);\n\n    const stepWorld = () => {\n      // Apply attractors\n      world.forEachRigidBody(body => {\n        attractorStates.forEach(attractorState => {\n          applyAttractorForceOnRigidBody(body, attractorState);\n        });\n      }); // Trigger beforeStep callbacks\n\n      beforeStepCallbacks.forEach(callback => {\n        callback(api);\n      });\n      world.step(eventQueue); // Trigger afterStep callbacks\n\n      afterStepCallbacks.forEach(callback => {\n        callback(api);\n      });\n    };\n\n    if (timeStepVariable) {\n      world.timestep = clampedDelta;\n      stepWorld();\n    } else {\n      world.timestep = _timeStep; // don't step time forwards if paused\n      // Increase accumulator\n\n      steppingState.accumulator += clampedDelta;\n\n      while (steppingState.accumulator >= _timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (_interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n\n        stepWorld();\n        steppingState.accumulator -= _timeStep;\n      }\n    }\n\n    const interpolationAlpha = timeStepVariable || !_interpolate || _paused ? 1 : steppingState.accumulator / _timeStep; // Update meshes\n\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n\n        state.isSleeping = rigidBody.isSleeping();\n      }\n\n      if (!rigidBody || rigidBody.isSleeping() || !state.setMatrix) {\n        return;\n      } // New states\n\n\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale); // Apply previous tick position\n\n\n        if (!(state.object instanceof InstancedMesh)) {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      } // Get new position\n\n\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n      if (state.object instanceof InstancedMesh) {\n        state.setMatrix(_matrix4);\n        state.object.instanceMatrix.needsUpdate = true;\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n          /* Collider events */\n\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      } // Sensor Intersections\n\n\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2()); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n  }, [_paused, _timeStep, _interpolate]);\n  useFrame((_, dt) => {\n    if (!_paused) step(dt);\n  }, updatePriority);\n  const context = useMemo(() => ({\n    rapier,\n    world: api,\n    physicsOptions: {\n      colliders: _colliders,\n      gravity: _gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    attractorStates,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: _paused,\n    step\n  }), [_paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, children);\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n// Colliders\nconst AnyCollider = /*#__PURE__*/memo( /*#__PURE__*/React.forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const ref = useRef(null);\n  const collidersRef = useMemo(() => {\n    if (forwardedRef !== null) {\n      return forwardedRef;\n    }\n\n    const result = /*#__PURE__*/React.createRef();\n    result.current = [];\n    return result;\n  }, []);\n  useEffect(() => {\n    const object = ref.current;\n    const worldScale = object.getWorldScale(new Vector3());\n    const colliders = []; // If this is an InstancedRigidBody api\n\n    if (rigidBodyContext && \"at\" in rigidBodyContext.api) {\n      rigidBodyContext.api.forEach((body, index) => {\n        var _rigidBodyContext$opt, _rigidBodyContext$opt2;\n\n        let instanceScale = worldScale;\n\n        if (\"scales\" in rigidBodyContext.options && rigidBodyContext !== null && rigidBodyContext !== void 0 && (_rigidBodyContext$opt = rigidBodyContext.options) !== null && _rigidBodyContext$opt !== void 0 && (_rigidBodyContext$opt2 = _rigidBodyContext$opt.scales) !== null && _rigidBodyContext$opt2 !== void 0 && _rigidBodyContext$opt2[index]) {\n          instanceScale = instanceScale.clone().multiply(vectorArrayToVector3(rigidBodyContext.options.scales[index]));\n        }\n\n        const collider = createColliderFromOptions(props, world, instanceScale, body.raw());\n        colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n        colliders.push(collider);\n      });\n    } else {\n      const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext && (rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.api).raw());\n      colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n      colliders.push(collider);\n    }\n\n    collidersRef.current = colliders;\n    return () => {\n      colliders.forEach(collider => {\n        world.removeCollider(collider);\n      });\n    };\n  }, []);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(collidersRef, mergedProps, colliderStates);\n  useColliderEvents(collidersRef, mergedProps, colliderEvents);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: ref,\n    name: name\n  }, children);\n}));\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"roundCuboid\",\n    ref: ref\n  }));\n});\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"ball\",\n    ref: ref\n  }));\n});\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"capsule\",\n    ref: ref\n  }));\n});\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"heightfield\",\n    ref: ref\n  }));\n});\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"trimesh\",\n    ref: ref\n  }));\n});\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cone\",\n    ref: ref\n  }));\n});\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cylinder\",\n    ref: ref\n  }));\n});\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"convexHull\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\nBallCollider.displayName = \"BallCollider\";\nCapsuleCollider.displayName = \"CapsuleCollider\";\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\nTrimeshCollider.displayName = \"TrimeshCollider\";\nConeCollider.displayName = \"ConeCollider\";\nCylinderCollider.displayName = \"CylinderCollider\";\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\nconst RigidBody = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    children,\n    type,\n    position,\n    rotation,\n    scale,\n    quaternion\n  } = props,\n        objectProps = _objectWithoutProperties(props, _excluded$1);\n\n  const [object, api, childColliderProps] = useRigidBody(props);\n  useImperativeHandle(ref, () => api);\n  const contextValue = useMemo(() => ({\n    ref: object,\n    api,\n    options: props\n  }), [object, api, props]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: object\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions,\n    world\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nfunction mapsEqual(map1, map2) {\n  var testVal;\n\n  if (map1.size !== map2.size) {\n    return false;\n  }\n\n  for (var [key, val] of map1) {\n    testVal = map2.get(key);\n\n    if (testVal !== val || testVal === undefined && !map2.has(key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst AttractorHelper = props => {\n  const {\n    scene\n  } = useThree();\n  const ref = useRef(null);\n  const normalsHelper = useRef();\n  const color = props.strength > 0 ? 0x0000ff : 0xff0000;\n  useEffect(() => {\n    if (ref.current) {\n      normalsHelper.current = new VertexNormalsHelper(ref.current, props.range, color);\n      normalsHelper.current.frustumCulled = false;\n      scene.add(normalsHelper.current);\n    }\n\n    return () => {\n      if (normalsHelper.current) {\n        scene.remove(normalsHelper.current);\n      }\n    };\n  }, [props]);\n  useFrame(() => {\n    if (ref.current) {\n      var _normalsHelper$curren;\n\n      const worldPosition = props.object.getWorldPosition(_vector3);\n      ref.current.position.copy(worldPosition);\n      (_normalsHelper$curren = normalsHelper.current) === null || _normalsHelper$curren === void 0 ? void 0 : _normalsHelper$curren.update();\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: ref,\n    position: props.object.position,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"sphereGeometry\", {\n    args: [0.2, 6, 6]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    color: color,\n    wireframe: true\n  }));\n};\n\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world,\n    attractorStates\n  } = useRapier();\n  const ref = useRef(null);\n  const [attractors, setAttractors] = useState([]);\n  const currMap = useRef(new Map());\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4)); // Update attractors\n\n    if (!mapsEqual(currMap.current, attractorStates)) {\n      setAttractors([...attractorStates.values()]);\n      currMap.current = new Map(attractorStates);\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)), attractors.map((attractor, i) => /*#__PURE__*/React.createElement(AttractorHelper, _extends({\n    key: attractor.object.uuid\n  }, attractor))));\n});\n\nconst _excluded = [\"positions\", \"rotations\", \"children\"];\nconst InstancedRigidBodies = /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const object = useRef(null);\n\n  const {\n    positions,\n    rotations,\n    children\n  } = props,\n        options = _objectWithoutProperties(props, _excluded);\n\n  const instancesRef = useRef([]);\n  const rigidBodyRefs = useRef([]);\n  const instancesRefGetter = useRef(() => {\n    if (!instancesRef.current) {\n      instancesRef.current = [];\n    }\n\n    return instancesRef.current;\n  });\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, physicsOptions), options);\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions);\n  useLayoutEffect(() => {\n    object.current.updateWorldMatrix(true, false);\n    const instances = instancesRefGetter.current();\n    const invertedWorld = object.current.matrixWorld.clone().invert();\n    object.current.traverseVisible(mesh => {\n      if (mesh instanceof InstancedMesh) {\n        mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n        const worldScale = mesh.getWorldScale(_scale);\n\n        for (let index = 0; index < mesh.count; index++) {\n          var _options$scales;\n\n          const desc = rigidBodyDescFromOptions(props);\n          const rigidBody = world.createRigidBody(desc);\n          rigidBodyRefs.current.push(rigidBody);\n          const scale = ((_options$scales = options.scales) === null || _options$scales === void 0 ? void 0 : _options$scales[index]) || [1, 1, 1];\n          const instanceScale = worldScale.clone().multiply(vectorArrayToVector3(scale));\n          rigidBodyStates.set(rigidBody.handle, createRigidBodyState({\n            rigidBody,\n            object: mesh,\n            setMatrix: matrix => mesh.setMatrixAt(index, matrix),\n            getMatrix: matrix => {\n              mesh.getMatrixAt(index, matrix);\n              return matrix;\n            },\n            worldScale: instanceScale\n          }));\n          const [x, y, z] = (positions === null || positions === void 0 ? void 0 : positions[index]) || [0, 0, 0];\n          const [rx, ry, rz] = (rotations === null || rotations === void 0 ? void 0 : rotations[index]) || [0, 0, 0];\n\n          _object3d.position.set(x, y, z);\n\n          _object3d.rotation.set(rx, ry, rz);\n\n          _object3d.applyMatrix4(invertedWorld);\n\n          mesh.setMatrixAt(index, _object3d.matrix);\n          rigidBody.setTranslation(_object3d.position, false);\n          rigidBody.setRotation(_object3d.quaternion, false);\n          const api = createRigidBodyApi({\n            current() {\n              return rigidBody;\n            }\n\n          });\n          instances.push({\n            rigidBody,\n            api\n          });\n        }\n      }\n    });\n    return () => {\n      instances.forEach(rb => {\n        world.removeRigidBody(rb.rigidBody);\n        rigidBodyStates.delete(rb.rigidBody.handle);\n      });\n      rigidBodyRefs.current = [];\n      instancesRef.current = [];\n    };\n  }, []);\n  const api = useMemo(() => createInstancedRigidBodiesApi(instancesRefGetter), []);\n  useImperativeHandle(ref, () => api);\n  useUpdateRigidBodyOptions(rigidBodyRefs, mergedOptions, rigidBodyStates, false);\n  useRigidBodyEvents(rigidBodyRefs, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: object,\n      api,\n      options: mergedOptions\n    };\n  }, [api, mergedOptions]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object\n  }, props.children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n});\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef();\n  const getJointRef = useRef(() => {\n    if (!jointRef.current) {\n      let rb1;\n      let rb2;\n\n      if (\"current\" in body1 && body1.current && \"current\" in body2 && body2.current) {\n        rb1 = world.getRigidBody(body1.current.handle);\n        rb2 = world.getRigidBody(body2.current.handle);\n        const newJoint = world.createImpulseJoint(params, rb1, rb2);\n        jointRef.current = newJoint;\n      }\n    }\n\n    return jointRef.current;\n  });\n  useEffect(() => {\n    const joint = getJointRef.current();\n    return () => {\n      if (joint) {\n        world.removeImpulseJoint(joint);\n        jointRef.current = undefined;\n      }\n    };\n  }, []);\n  const api = useMemo(() => createJointApi(getJointRef), []);\n  return api;\n};\n/**\n *\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n */\n\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vectorArrayToVector3(body1Anchor), tupleToObject(body1LocalFrame, [\"x\", \"y\", \"z\", \"w\"]), vectorArrayToVector3(body2Anchor), tupleToObject(body2LocalFrame, [\"x\", \"y\", \"z\", \"w\"])));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n */\n\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n */\n\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n */\n\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\n\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, Attractor, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, Debug, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundCuboidCollider, TrimeshCollider, interactionGroups, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useSphericalJoint };\n", "import deepEqual from 'fast-deep-equal';\n\nconst globalCache = [];\n\nfunction handleAsset(fn, cache, args, lifespan = 0, preload = false) {\n  for (const entry of cache) {\n    // Find a match\n    if (deepEqual(args, entry.args)) {\n      // If we're pre-loading and the element is present, just return\n      if (preload) return; // If an error occurred, throw\n\n      if (entry.error) throw entry.error; // If a response was successful, return\n\n      if (entry.response) return entry.response; // If the promise is still unresolved, throw\n\n      throw entry.promise;\n    }\n  } // The request is new or has changed.\n\n\n  const entry = {\n    args,\n    promise: // Make the promise request.\n    fn(...args) // Response can't be undefined or else the loop above wouldn't be able to return it\n    // This is for promises that do not return results (delays for instance)\n    .then(response => entry.response = response != null ? response : true).catch(e => entry.error = e != null ? e : 'unknown error').then(() => {\n      if (lifespan > 0) {\n        setTimeout(() => {\n          const index = cache.indexOf(entry);\n          if (index !== -1) cache.splice(index, 1);\n        }, lifespan);\n      }\n    })\n  };\n  cache.push(entry);\n  if (!preload) throw entry.promise;\n}\n\nfunction clear(cache, ...args) {\n  if (args === undefined || args.length === 0) cache.splice(0, cache.length);else {\n    const entry = cache.find(entry => deepEqual(args, entry.args));\n\n    if (entry) {\n      const index = cache.indexOf(entry);\n      if (index !== -1) cache.splice(index, 1);\n    }\n  }\n}\n\nfunction createAsset(fn, lifespan = 0) {\n  const cache = [];\n  return {\n    /**\n     * @throws Suspense Promise if asset is not yet ready\n     * @throws Error if the promise rejected for some reason\n     */\n    read: (...args) => handleAsset(fn, cache, args, lifespan),\n    preload: (...args) => void handleAsset(fn, cache, args, lifespan, true),\n    clear: (...args) => clear(cache, ...args),\n    peek: (...args) => {\n      var _cache$find;\n\n      return (_cache$find = cache.find(entry => deepEqual(args, entry.args))) == null ? void 0 : _cache$find.response;\n    }\n  };\n}\n\nfunction useAsset(fn, ...args) {\n  return handleAsset(fn, globalCache, args, useAsset.lifespan);\n}\n\nuseAsset.lifespan = 0;\n\nuseAsset.clear = (...args) => clear(globalCache, ...args);\n\nuseAsset.preload = (fn, ...args) => void handleAsset(fn, globalCache, args, useAsset.lifespan, true);\n\nuseAsset.peek = (...args) => {\n  var _globalCache$find;\n\n  return (_globalCache$find = globalCache.find(entry => deepEqual(args, entry.args))) == null ? void 0 : _globalCache$find.response;\n};\n\nexport { createAsset, useAsset };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAMA,WAAO,UAAU,SAAS,MAAM,GAAG,GAAG;AACpC,UAAI,MAAM;AAAG,eAAO;AAEpB,UAAI,KAAK,KAAK,OAAO,KAAK,YAAY,OAAO,KAAK,UAAU;AAC1D,YAAI,EAAE,gBAAgB,EAAE;AAAa,iBAAO;AAE5C,YAAI,QAAQ,GAAG;AACf,YAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,mBAAS,EAAE;AACX,cAAI,UAAU,EAAE;AAAQ,mBAAO;AAC/B,eAAK,IAAI,QAAQ,QAAQ;AACvB,gBAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;AAAG,qBAAO;AACjC,iBAAO;AAAA,QACT;AAIA,YAAI,EAAE,gBAAgB;AAAQ,iBAAO,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE;AAC5E,YAAI,EAAE,YAAY,OAAO,UAAU;AAAS,iBAAO,EAAE,QAAQ,MAAM,EAAE,QAAQ;AAC7E,YAAI,EAAE,aAAa,OAAO,UAAU;AAAU,iBAAO,EAAE,SAAS,MAAM,EAAE,SAAS;AAEjF,eAAO,OAAO,KAAK,CAAC;AACpB,iBAAS,KAAK;AACd,YAAI,WAAW,OAAO,KAAK,CAAC,EAAE;AAAQ,iBAAO;AAE7C,aAAK,IAAI,QAAQ,QAAQ;AACvB,cAAI,CAAC,OAAO,UAAU,eAAe,KAAK,GAAG,KAAK,CAAC,CAAC;AAAG,mBAAO;AAEhE,aAAK,IAAI,QAAQ,QAAQ,KAAI;AAC3B,cAAI,MAAM,KAAK,CAAC;AAEhB,cAAI,CAAC,MAAM,EAAE,GAAG,GAAG,EAAE,GAAG,CAAC;AAAG,mBAAO;AAAA,QACrC;AAEA,eAAO;AAAA,MACT;AAGA,aAAO,MAAI,KAAK,MAAI;AAAA,IACtB;AAAA;AAAA;;;AC1CA,mBAA4J;;;ACH5J,6BAAsB;AAEtB,IAAM,cAAc,CAAC;AAErB,SAAS,YAAY,IAAI,OAAO,MAAM,WAAW,GAAG,UAAU,OAAO;AACnE,aAAWA,UAAS,OAAO;AAEzB,YAAI,uBAAAC,SAAU,MAAMD,OAAM,IAAI,GAAG;AAE/B,UAAI;AAAS;AAEb,UAAIA,OAAM;AAAO,cAAMA,OAAM;AAE7B,UAAIA,OAAM;AAAU,eAAOA,OAAM;AAEjC,YAAMA,OAAM;AAAA,IACd;AAAA,EACF;AAGA,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA;AAAA;AAAA,MACA,GAAG,GAAG,IAAI,EAET,KAAK,cAAY,MAAM,WAAW,YAAY,OAAO,WAAW,IAAI,EAAE,MAAM,OAAK,MAAM,QAAQ,KAAK,OAAO,IAAI,eAAe,EAAE,KAAK,MAAM;AAC1I,YAAI,WAAW,GAAG;AAChB,qBAAW,MAAM;AACf,kBAAM,QAAQ,MAAM,QAAQ,KAAK;AACjC,gBAAI,UAAU;AAAI,oBAAM,OAAO,OAAO,CAAC;AAAA,UACzC,GAAG,QAAQ;AAAA,QACb;AAAA,MACF,CAAC;AAAA;AAAA,EACH;AACA,QAAM,KAAK,KAAK;AAChB,MAAI,CAAC;AAAS,UAAM,MAAM;AAC5B;AAEA,SAAS,MAAM,UAAU,MAAM;AAC7B,MAAI,SAAS,UAAa,KAAK,WAAW;AAAG,UAAM,OAAO,GAAG,MAAM,MAAM;AAAA,OAAO;AAC9E,UAAM,QAAQ,MAAM,KAAK,CAAAA,eAAS,uBAAAC,SAAU,MAAMD,OAAM,IAAI,CAAC;AAE7D,QAAI,OAAO;AACT,YAAM,QAAQ,MAAM,QAAQ,KAAK;AACjC,UAAI,UAAU;AAAI,cAAM,OAAO,OAAO,CAAC;AAAA,IACzC;AAAA,EACF;AACF;AAoBA,SAAS,SAAS,OAAO,MAAM;AAC7B,SAAO,YAAY,IAAI,aAAa,MAAM,SAAS,QAAQ;AAC7D;AAEA,SAAS,WAAW;AAEpB,SAAS,QAAQ,IAAI,SAAS,MAAM,aAAa,GAAG,IAAI;AAExD,SAAS,UAAU,CAAC,OAAO,SAAS,KAAK,YAAY,IAAI,aAAa,MAAM,SAAS,UAAU,IAAI;AAEnG,SAAS,OAAO,IAAI,SAAS;AAC3B,MAAI;AAEJ,UAAQ,oBAAoB,YAAY,KAAK,eAAS,uBAAAE,SAAU,MAAM,MAAM,IAAI,CAAC,MAAM,OAAO,SAAS,kBAAkB;AAC3H;;;ADzEA,SAAS,gBAAgB,KAAK,KAAK,OAAO;AACxC,MAAI,OAAO,KAAK;AACd,WAAO,eAAe,KAAK,KAAK;AAAA,MAC9B;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,IACZ,CAAC;AAAA,EACH,OAAO;AACL,QAAI,GAAG,IAAI;AAAA,EACb;AAEA,SAAO;AACT;AAEA,SAAS,QAAQ,QAAQ,gBAAgB;AACvC,MAAI,OAAO,OAAO,KAAK,MAAM;AAE7B,MAAI,OAAO,uBAAuB;AAChC,QAAI,UAAU,OAAO,sBAAsB,MAAM;AACjD,uBAAmB,UAAU,QAAQ,OAAO,SAAU,KAAK;AACzD,aAAO,OAAO,yBAAyB,QAAQ,GAAG,EAAE;AAAA,IACtD,CAAC,IAAI,KAAK,KAAK,MAAM,MAAM,OAAO;AAAA,EACpC;AAEA,SAAO;AACT;AAEA,SAAS,eAAe,QAAQ;AAC9B,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,QAAI,SAAS,QAAQ,UAAU,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC;AACpD,QAAI,IAAI,QAAQ,OAAO,MAAM,GAAG,IAAE,EAAE,QAAQ,SAAU,KAAK;AACzD,sBAAgB,QAAQ,KAAK,OAAO,GAAG,CAAC;AAAA,IAC1C,CAAC,IAAI,OAAO,4BAA4B,OAAO,iBAAiB,QAAQ,OAAO,0BAA0B,MAAM,CAAC,IAAI,QAAQ,OAAO,MAAM,CAAC,EAAE,QAAQ,SAAU,KAAK;AACjK,aAAO,eAAe,QAAQ,KAAK,OAAO,yBAAyB,QAAQ,GAAG,CAAC;AAAA,IACjF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEA,IAAM,cAAc,IAAI,WAAW;AACnC,IAAI,MAAM;AACV,IAAM,WAAW,IAAI,QAAQ;AAC7B,IAAM,YAAY,IAAI,SAAS;AAC/B,IAAM,WAAW,IAAI,QAAQ;AAC7B,IAAM,YAAY,IAAI,QAAQ;AAC9B,IAAM,YAAY,IAAI,WAAW;AACjC,IAAM,SAAS,IAAI,QAAQ;AAE3B,IAAM,uBAAuB,SAAO;AAClC,QAAM,CAAC,GAAG,GAAG,CAAC,IAAI;AAClB,SAAO,IAAI,QAAQ,GAAG,GAAG,CAAC;AAC5B;AACA,IAAM,gBAAgB,CAAC,OAAO,SAAS;AACrC,SAAO,KAAK,OAAO,CAAC,KAAK,KAAK,MAAM;AAClC,QAAI,GAAG,IAAI,MAAM,CAAC;AAClB,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP;AACA,IAAM,yBAAyB,CAAC;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AACF,MAAM,SAAS,IAAI,GAAG,GAAG,CAAC;AAC1B,IAAM,+BAA+B,CAAC;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM,YAAY,IAAI,GAAG,GAAG,GAAG,CAAC;AAChC,IAAM,mBAAmB;AAAA,EACvB,OAAO;AAAA,EACP,SAAS;AAAA,EACT,mBAAmB;AAAA,EACnB,mBAAmB;AACrB;AACA,IAAM,0BAA0B,UAAQ,iBAAiB,IAAI;AAC7D,IAAM,gBAAgB,CAAC,UAAU,UAAU;AACzC,QAAM,cAAc,MAAM,KAAK,QAAQ;AAEvC,WAAS,IAAI,GAAG,IAAI,SAAS,SAAS,GAAG,KAAK;AAC5C,gBAAY,IAAI,CAAC,KAAK,MAAM;AAC5B,gBAAY,IAAI,IAAI,CAAC,KAAK,MAAM;AAChC,gBAAY,IAAI,IAAI,CAAC,KAAK,MAAM;AAAA,EAClC;AAEA,SAAO;AACT;AACA,IAAM,gBAAgB,OAAK;AACzB,MAAI,CAAC;AAAG,WAAO,CAAC,CAAC;AAEjB,MAAI,aAAa,YAAY;AAC3B,WAAO,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;AAAA,EAC5B;AAEA,MAAI,aAAa,WAAW,aAAa,OAAO;AAC9C,WAAO,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;AAAA,EACvB;AAEA,MAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,WAAO;AAAA,EACT;AAEA,SAAO,CAAC,CAAC;AACX;AACA,SAAS,SAAS,cAAc;AAC9B,QAAM,UAAM,qBAAO;AAEnB,MAAI,IAAI,YAAY,QAAW;AAC7B,QAAI,UAAU;AAAA,MACZ,OAAO,OAAO,iBAAiB,aAAa,aAAa,IAAI;AAAA,IAC/D;AAAA,EACF;AAEA,SAAO,IAAI,QAAQ;AACrB;AAEA,IAAM,qBAAqB,SAAO;AAChC,SAAO;AAAA,IACL,KAAK,MAAM,IAAI,QAAQ;AAAA,IAEvB,IAAI,SAAS;AACX,aAAO,IAAI,QAAQ,EAAE;AAAA,IACvB;AAAA,IAEA,MAAM,MAAM,IAAI,QAAQ,EAAE,KAAK;AAAA,IAE/B,aAAa,eAAe,SAAS,MAAM;AACzC,UAAI,QAAQ,EAAE,aAAa,eAAe,MAAM;AAAA,IAClD;AAAA,IAEA,mBAAmB,cAAc,SAAS,MAAM;AAC9C,UAAI,QAAQ,EAAE,mBAAmB,cAAc,MAAM;AAAA,IACvD;AAAA,IAEA,qBAAqB,CAAC,eAAe,cAAc,SAAS,SAAS,IAAI,QAAQ,EAAE,oBAAoB,eAAe,cAAc,MAAM;AAAA,IAC1I,UAAU,CAAC,OAAO,SAAS,SAAS,IAAI,QAAQ,EAAE,SAAS,OAAO,MAAM;AAAA,IACxE,iBAAiB,CAAC,OAAO,OAAO,SAAS,SAAS,IAAI,QAAQ,EAAE,gBAAgB,OAAO,OAAO,MAAM;AAAA,IACpG,WAAW,CAAC,QAAQ,SAAS,SAAS,IAAI,QAAQ,EAAE,UAAU,QAAQ,MAAM;AAAA,IAE5E,cAAc;AACZ,aAAO,uBAAuB,IAAI,QAAQ,EAAE,YAAY,CAAC;AAAA,IAC3D;AAAA,IAEA,gBAAgB,CAAC,aAAa,SAAS,SAAS,IAAI,QAAQ,EAAE,eAAe,aAAa,MAAM;AAAA,IAEhG,WAAW;AACT,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,IAAI,IAAI,QAAQ,EAAE,SAAS;AAC3B,aAAO,IAAI,WAAW,GAAG,GAAG,GAAG,CAAC;AAAA,IAClC;AAAA,IAEA,aAAa,CAAC,UAAU,SAAS,SAAS;AACxC,UAAI,QAAQ,EAAE,YAAY,UAAU,MAAM;AAAA,IAC5C;AAAA,IAEA,SAAS;AACP,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,MACF,IAAI,IAAI,QAAQ,EAAE,OAAO;AACzB,aAAO,IAAI,QAAQ,GAAG,GAAG,CAAC;AAAA,IAC5B;AAAA,IAEA,WAAW,CAAC,UAAU,SAAS,SAAS,IAAI,QAAQ,EAAE,UAAU,UAAU,MAAM;AAAA,IAEhF,SAAS;AACP,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,MACF,IAAI,IAAI,QAAQ,EAAE,OAAO;AACzB,aAAO,IAAI,QAAQ,GAAG,GAAG,CAAC;AAAA,IAC5B;AAAA,IAEA,WAAW,CAAC,UAAU,SAAS,SAAS,IAAI,QAAQ,EAAE,UAAU,UAAU,MAAM;AAAA,IAEhF,gBAAgB;AACd,aAAO,IAAI,QAAQ,EAAE,cAAc;AAAA,IACrC;AAAA,IAEA,kBAAkB,YAAU,IAAI,QAAQ,EAAE,iBAAiB,MAAM;AAAA,IAEjE,iBAAiB;AACf,aAAO,IAAI,QAAQ,EAAE,eAAe;AAAA,IACtC;AAAA,IAEA,mBAAmB,YAAU,IAAI,QAAQ,EAAE,kBAAkB,MAAM;AAAA,IACnE,0BAA0B,cAAY;AACpC,UAAI,QAAQ,EAAE,yBAAyB,QAAQ;AAAA,IACjD;AAAA,IACA,6BAA6B,iBAAe,IAAI,QAAQ,EAAE,4BAA4B,WAAW;AAAA,IACjG,aAAa,CAAC,SAAS,SAAS,IAAI,QAAQ,EAAE,YAAY,MAAM;AAAA,IAChE,cAAc,CAAC,SAAS,SAAS,IAAI,QAAQ,EAAE,aAAa,MAAM;AAAA,IAClE,eAAe,CAAC,QAAQ,SAAS,SAAS,IAAI,QAAQ,EAAE,cAAc,QAAQ,MAAM;AAAA,IACpF,kBAAkB,CAAC,QAAQ,SAAS,SAAS,IAAI,QAAQ,EAAE,iBAAiB,QAAQ,MAAM;AAAA,IAC1F,qBAAqB,CAAC,GAAG,GAAG,GAAG,SAAS,SAAS,IAAI,QAAQ,EAAE,oBAAoB,GAAG,GAAG,GAAG,MAAM;AAAA,IAClG,wBAAwB,CAAC,GAAG,GAAG,GAAG,SAAS,SAAS,IAAI,QAAQ,EAAE,uBAAuB,GAAG,GAAG,GAAG,MAAM;AAAA,EAC1G;AACF;AACA,IAAM,gCAAgC,mBAAiB;AAAA,EACrD,IAAI,WAAS,aAAa,QAAQ,EAAE,KAAK,EAAE;AAAA,EAE3C,QAAQ,UAAU;AAChB,WAAO,aAAa,QAAQ,EAAE,IAAI,OAAK,EAAE,GAAG,EAAE,QAAQ,QAAQ;AAAA,EAChE;AAAA,EAEA,IAAI,QAAQ;AACV,WAAO,aAAa,QAAQ,EAAE;AAAA,EAChC;AAEF;AACA,IAAM,iBAAiB,SAAO;AAC5B,SAAO;AAAA,IACL,KAAK,MAAM,IAAI,QAAQ;AAAA,IACvB,aAAa,YAAU,IAAI,QAAQ,EAAE,YAAY,MAAM;AAAA,IACvD,cAAc,YAAU,IAAI,QAAQ,EAAE,aAAa,MAAM;AAAA,IACzD,iBAAiB,UAAQ,IAAI,QAAQ,EAAE,gBAAgB,IAAI;AAAA,IAC3D,gBAAgB,CAAC,MAAM,cAAc,IAAI,QAAQ,EAAE,eAAe,MAAM,SAAS;AAAA,IACjF,iBAAiB,eAAa;AAC5B,UAAI,CAAC,IAAI,QAAQ,EAAE,OAAO,SAAS,UAAU,MAAM;AAAG;AACtD,UAAI,QAAQ,EAAE,gBAAgB,SAAS;AAAA,IACzC;AAAA,IACA,gBAAgB,CAAC,UAAU,SAAS,SAAS;AAC3C,UAAI,CAAC,IAAI,QAAQ,EAAE,UAAU,SAAS,SAAS,MAAM;AAAG;AACxD,UAAI,QAAQ,EAAE,eAAe,UAAU,MAAM;AAAA,IAC/C;AAAA,IACA,oBAAoB,CAAC,QAAQ,YAAY,YAAY,SAAS,SAAS,IAAI,QAAQ,EAAE,mBAAmB,QAAQ,YAAY,YAAY,MAAM;AAAA,IAC9I,oBAAoB,CAAC,OAAO,SAAS,SAAS;AAC5C,UAAI,CAAC,IAAI,QAAQ,EAAE,cAAc,SAAS,MAAM,MAAM;AAAG;AACzD,UAAI,QAAQ,EAAE,mBAAmB,OAAO,MAAM;AAAA,IAChD;AAAA,IACA,iBAAiB,cAAY,IAAI,QAAQ,EAAE,gBAAgB,QAAQ;AAAA,IACnE,YAAY,CAAC;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,IACF,MAAM,IAAI,QAAQ,EAAE,UAAU;AAAA,MAC5B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACA,aAAa,MAAM,IAAI,QAAQ,EAAE,YAAY;AAAA,EAC/C;AACF;AACA,IAAM,iBAAiB,SAAO;AAC5B,SAAO;AAAA,IACL,KAAK,MAAM,IAAI,QAAQ;AAAA,IAEvB,IAAI,SAAS;AACX,aAAO,IAAI,QAAQ,EAAE;AAAA,IACvB;AAAA,IAEA,wBAAwB,CAAC,WAAW,WAAW,YAAY,IAAI,QAAQ,EAAE,uBAAuB,WAAW,WAAW,OAAO;AAAA,IAC7H,wBAAwB,CAAC,WAAW,YAAY,IAAI,QAAQ,EAAE,uBAAuB,WAAW,OAAO;AAAA,EACzG;AACF;AAEA,IAAM,oBAAoB,CAAC,OAAO,MAAM,UAAU;AAChD,QAAM,UAAU,KAAK,MAAM;AAE3B,MAAI,UAAU,eAAe;AAC3B,UAAM,IAAI,QAAQ,CAAC;AACnB,MAAE,KAAK,MAAM;AACb,MAAE,KAAK,MAAM;AACb,MAAE,KAAK,MAAM;AACb,WAAO;AAAA,EACT;AAGA,MAAI,UAAU,aAAa,UAAU,cAAc;AACjD,YAAQ,CAAC,IAAI,cAAc,QAAQ,CAAC,GAAG,KAAK;AAC5C,WAAO;AAAA,EACT;AAGA,QAAM,aAAa,CAAC,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC;AAC/D,SAAO,QAAQ,IAAI,CAAC,KAAK,UAAU,WAAW,KAAK,IAAI,GAAG;AAC5D;AACA,IAAM,4BAA4B,CAAC,SAAS,OAAO,OAAO,cAAc;AACtE,QAAM,aAAa,kBAAkB,QAAQ,OAAO,QAAQ,MAAM,KAAK;AAEvE,QAAM,OAAO,GAAa,QAAQ,KAAK,EAAE,GAAG,UAAU;AACtD,SAAO,MAAM,eAAe,MAAM,SAAS;AAC7C;AACA,IAAM,8BAA8B;AAEpC,IAAM,yBAAyB,CAAC,UAAU,YAAY;AACpD,MAAI,QAAQ,YAAY,QAAW;AACjC,QAAI,QAAQ,SAAS,UAAa,QAAQ,mBAAmB,QAAW;AACtE,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AAEA,aAAS,WAAW,QAAQ,OAAO;AACnC;AAAA,EACF;AAEA,MAAI,QAAQ,SAAS,QAAW;AAC9B,QAAI,QAAQ,mBAAmB,QAAW;AACxC,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AAEA,aAAS,QAAQ,QAAQ,IAAI;AAC7B;AAAA,EACF;AAEA,MAAI,QAAQ,mBAAmB,QAAW;AACxC,aAAS,kBAAkB,QAAQ,eAAe,MAAM,QAAQ,eAAe,cAAc,QAAQ,eAAe,yBAAyB,QAAQ,eAAe,wBAAwB;AAAA,EAC9L;AACF;AAEA,IAAM,yBAAyB;AAAA,EAC7B,QAAQ,CAAC,UAAU,UAAU;AAC3B,aAAS,UAAU,KAAK;AAAA,EAC1B;AAAA,EACA,iBAAiB,CAAC,UAAU,UAAU;AACpC,aAAS,mBAAmB,KAAK;AAAA,EACnC;AAAA,EACA,cAAc,CAAC,UAAU,UAAU;AACjC,aAAS,gBAAgB,KAAK;AAAA,EAChC;AAAA,EACA,UAAU,CAAC,UAAU,UAAU;AAC7B,aAAS,YAAY,KAAK;AAAA,EAC5B;AAAA,EACA,qBAAqB,CAAC,UAAU,UAAU;AACxC,aAAS,uBAAuB,KAAK;AAAA,EACvC;AAAA,EACA,aAAa,CAAC,UAAU,UAAU;AAChC,aAAS,eAAe,KAAK;AAAA,EAC/B;AAAA,EACA,wBAAwB,CAAC,UAAU,UAAU;AAC3C,aAAS,0BAA0B,KAAK;AAAA,EAC1C;AAAA;AAAA,EAEA,YAAY,MAAM;AAAA,EAAC;AAAA,EACnB,UAAU,MAAM;AAAA,EAAC;AAAA,EACjB,UAAU,MAAM;AAAA,EAAC;AAAA,EACjB,OAAO,MAAM;AAAA,EAAC;AAChB;AACA,IAAM,4BAA4B,OAAO,KAAK,sBAAsB;AACpE,IAAM,qBAAqB,CAAC,UAAU,SAAS,WAAW;AACxD,QAAM,QAAQ,OAAO,IAAI,SAAS,MAAM;AAExC,MAAI,OAAO;AACT,QAAI;AAGJ,UAAM,mBAAmB,MAAM,OAAO,OAAO,cAAc,QAAQ;AACnE,UAAM,6BAA6B,qBAAqB,MAAM,iBAAiB,QAAQ,uBAAuB,SAAS,SAAS,mBAAmB,YAAY,MAAM,EAAE,OAAO;AAC9K,UAAM,OAAO,kBAAkB,MAAM,KAAK;AAE1C,aAAS,KAAK,MAAM,OAAO,WAAW;AAEtC,QAAI,2BAA2B;AAC7B,eAAS,YAAY,yBAAyB;AAAA,IAChD;AAEA,aAAS,UAAU,WAAW,WAAW,MAAM;AAE/C,QAAI,SAAS,OAAO,GAAG;AACrB,eAAS,wBAAwB;AAAA,QAC/B,GAAG,UAAU,IAAI,iBAAiB;AAAA,QAClC,GAAG,UAAU,IAAI,iBAAiB;AAAA,QAClC,GAAG,UAAU,IAAI,iBAAiB;AAAA,MACpC,CAAC;AACD,eAAS,qBAAqB,SAAS;AAAA,IACzC,OAAO;AACL,eAAS,eAAe;AAAA,QACtB,GAAG,UAAU,IAAI,iBAAiB;AAAA,QAClC,GAAG,UAAU,IAAI,iBAAiB;AAAA,QAClC,GAAG,UAAU,IAAI,iBAAiB;AAAA,MACpC,CAAC;AACD,eAAS,YAAY,SAAS;AAAA,IAChC;AAEA,8BAA0B,QAAQ,SAAO;AACvC,UAAI,OAAO,SAAS;AAClB,cAAM,SAAS,QAAQ,GAAG;AAC1B,+BAAuB,GAAG;AAAA,UAAE;AAAA;AAAA,UAC5B;AAAA,UAAQ;AAAA,QAAO;AAAA,MACjB;AAAA,IACF,CAAC;AAGD,2BAAuB,UAAU,OAAO;AAAA,EAC1C;AACF;AACA,IAAM,2BAA2B,CAAC,cAAc,OAAO,WAAW;AAEhE,QAAM,8BAA0B,sBAAQ,MAAM,0BAA0B,QAAQ,SAAO;AACrF,WAAO,cAAc,MAAM,GAAG,CAAC;AAAA,EACjC,CAAC,GAAG,CAAC,KAAK,CAAC;AACX,8BAAU,MAAM;AACd,iBAAa,QAAQ,QAAQ,cAAY;AACvC,yBAAmB,UAAU,OAAO,MAAM;AAAA,IAC5C,CAAC;AAAA,EACH,GAAG,uBAAuB;AAC5B;AAEA,IAAM,wBAAwB,WAAS;AACrC,MAAI,OAAO;AACX,QAAM,kBAAkB,OAAK;AAC3B,QAAI,EAAE,SAAS,iBAAiB;AAAgB,aAAO;AAAA,EACzD,CAAC;AACD,SAAO;AACT;AAEA,IAAM,sBAAsB,CAAC,UAAU,QAAQ,oBAAoB;AACjE,SAAO;AAAA,IACL;AAAA,IACA,aAAa,mBAAmB;AAAA,IAChC;AAAA,EACF;AACF;AACA,IAAM,kBAAkB;AAAA,EACtB,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,SAAS;AACX;AACA,IAAM,kCAAkC,CAAC;AAAA,EACvC;AAAA,EACA,qBAAqB,uBAAuB;AAAA,EAC5C;AACF,MAAM;AACJ,QAAM,gBAAgB,CAAC;AACvB,SAAO,kBAAkB,MAAM,KAAK;AACpC,QAAM,4BAA4B,OAAO,YAAY,MAAM,EAAE,OAAO;AAEpE,QAAM,oBAAoB,WAAS;AACjC,QAAI,YAAY,OAAO;AACrB,UAAI,wBAAwB,sBAAsB,KAAK;AAAG;AAC1D,YAAM,aAAa,MAAM,cAAc,MAAM;AAC7C,YAAM,QAAQ,gBAAgB,QAAQ,aAAa,QAAQ;AAC3D,YAAM,kBAAkB,MAAM,KAAK;AAEnC,eAAS,KAAK,MAAM,WAAW,EAAE,YAAY,yBAAyB,EAAE,UAAU,WAAW,WAAW,MAAM;AAE9G,YAAM,gBAAgB,IAAI,MAAM,EAAE,kBAAkB,WAAW,KAAK;AACpE,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,MACF,IAAI,4BAA4B,UAAU,QAAQ,aAAa,QAAQ;AACvE,oBAAc,KAAK,eAAe,eAAe,CAAC,GAAG,OAAO,GAAG,CAAC,GAAG;AAAA,QACjE;AAAA,QACA;AAAA,QACA,UAAU,CAAC,cAAc,GAAG,cAAc,GAAG,cAAc,CAAC;AAAA,QAC5D,UAAU,CAAC,UAAU,IAAI,OAAO,IAAI,WAAW,GAAG,UAAU,IAAI,OAAO,IAAI,WAAW,GAAG,UAAU,IAAI,OAAO,IAAI,WAAW,CAAC;AAAA,QAC9H,OAAO,CAAC,WAAW,GAAG,WAAW,GAAG,WAAW,CAAC;AAAA,MAClD,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AAEA,MAAI,QAAQ,kBAAkB;AAC5B,WAAO,SAAS,iBAAiB;AAAA,EACnC,OAAO;AACL,WAAO,gBAAgB,iBAAiB;AAAA,EAC1C;AAEA,SAAO;AACT;AACA,IAAM,8BAA8B,CAAC,UAAU,cAAc;AAC3D,UAAQ,WAAW;AAAA,IACjB,KAAK,UACH;AACE,eAAS,mBAAmB;AAC5B,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,YAAM,OAAO,YAAY,QAAQ,IAAI,QAAQ,CAAC;AAC9C,aAAO;AAAA,QACL,MAAM,CAAC,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,CAAC;AAAA,QACzC,QAAQ,YAAY,UAAU,IAAI,QAAQ,CAAC;AAAA,MAC7C;AAAA,IACF;AAAA,IAEF,KAAK,QACH;AACE,eAAS,sBAAsB;AAC/B,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,YAAM,SAAS,eAAe;AAC9B,aAAO;AAAA,QACL,MAAM,CAAC,MAAM;AAAA,QACb,QAAQ,eAAe;AAAA,MACzB;AAAA,IACF;AAAA,IAEF,KAAK,WACH;AACE,UAAI;AAEJ,YAAM,iBAAiB,SAAS,QAAQ,SAAS,MAAM,IAAI,cAAc,QAAQ;AACjF,aAAO;AAAA,QACL,MAAM,CAAC,eAAe,WAAW,SAAS,QAAQ,wBAAwB,eAAe,WAAW,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB,KAAK;AAAA,QACnL,QAAQ,IAAI,QAAQ;AAAA,MACtB;AAAA,IACF;AAAA,IAEF,KAAK,QACH;AACE,YAAM,IAAI,SAAS,MAAM;AACzB,aAAO;AAAA,QACL,MAAM,CAAC,EAAE,WAAW,SAAS,KAAK;AAAA,QAClC,QAAQ,IAAI,QAAQ;AAAA,MACtB;AAAA,IACF;AAAA,EACJ;AAEA,SAAO;AAAA,IACL,MAAM,CAAC;AAAA,IACP,QAAQ,IAAI,QAAQ;AAAA,EACtB;AACF;AACA,IAAM,oBAAoB,CAAC,cAAc,OAAO,WAAW;AACzD,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,8BAAU,MAAM;AACd,QAAI;AAEJ,KAAC,wBAAwB,aAAa,aAAa,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB,QAAQ,cAAY;AAC/I,YAAM,oBAAoB,CAAC,EAAE,oBAAoB,mBAAmB,uBAAuB;AAC3F,YAAM,uBAAuB,CAAC,CAAC;AAE/B,UAAI,qBAAqB,sBAAsB;AAC7C,iBAAS,gBAAgB,GAAa,mBAAmB,GAAa,oBAAoB;AAAA,MAC5F,WAAW,mBAAmB;AAC5B,iBAAS,gBAAgB,GAAa,gBAAgB;AAAA,MACxD,WAAW,sBAAsB;AAC/B,iBAAS,gBAAgB,GAAa,oBAAoB;AAAA,MAC5D;AAEA,aAAO,IAAI,SAAS,QAAQ;AAAA,QAC1B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AACD,WAAO,MAAM;AACX,UAAI;AAEJ,OAAC,yBAAyB,aAAa,aAAa,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,QAAQ,cAAY,OAAO,OAAO,SAAS,MAAM,CAAC;AAAA,IACpL;AAAA,EACF,GAAG,CAAC,kBAAkB,iBAAiB,qBAAqB,oBAAoB,cAAc,CAAC;AACjG;AAEA,IAAM,2BAA2B,aAAW;AAC1C,MAAI;AAEJ,QAAM,OAAO,yBAAyB,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,SAAS,SAAS;AAClH,QAAM,OAAO,IAAI,GAAc,IAAI;AAEnC,OAAK,YAAY,oBAAoB,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,cAAc,QAAQ,sBAAsB,SAAS,oBAAoB;AACxK,SAAO;AACT;AACA,IAAM,uBAAuB,CAAC;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AACJ,SAAO,kBAAkB,MAAM,KAAK;AACpC,QAAM,sBAAsB,OAAO,OAAO,YAAY,MAAM,EAAE,OAAO;AACrE,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,WAAW,YAAY,YAAY,YAAU;AAC3C,aAAO,OAAO,KAAK,MAAM;AAAA,IAC3B;AAAA,IACA,WAAW,YAAY,YAAY,YAAU,OAAO,KAAK,OAAO,MAAM;AAAA,IACtE,OAAO,cAAc,OAAO,cAAc,MAAM,EAAE,MAAM;AAAA,IACxD,YAAY;AAAA,EACd;AACF;AACA,IAAM,0BAA0B;AAAA,EAC9B,cAAc,CAAC,IAAI,UAAU;AAC3B,OAAG,gBAAgB,OAAO,IAAI;AAAA,EAChC;AAAA,EACA,eAAe,CAAC,IAAI,UAAU;AAC5B,OAAG,iBAAiB,KAAK;AAAA,EAC3B;AAAA,EACA,gBAAgB,CAAC,IAAI,UAAU;AAC7B,OAAG,kBAAkB,KAAK;AAAA,EAC5B;AAAA,EACA,kBAAkB,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM;AACnC,OAAG,oBAAoB,GAAG,GAAG,GAAG,IAAI;AAAA,EACtC;AAAA,EACA,qBAAqB,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM;AACtC,OAAG,uBAAuB,GAAG,GAAG,GAAG,IAAI;AAAA,EACzC;AAAA,EACA,eAAe,CAAC,IAAI,UAAU;AAC5B,OAAG,cAAc,OAAO,IAAI;AAAA,EAC9B;AAAA,EACA,kBAAkB,CAAC,IAAI,UAAU;AAC/B,OAAG,iBAAiB,OAAO,IAAI;AAAA,EACjC;AAAA,EACA,iBAAiB,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM;AAClC,OAAG,UAAU;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,IACF,GAAG,IAAI;AAAA,EACT;AAAA,EACA,gBAAgB,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM;AACjC,OAAG,UAAU;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,IACF,GAAG,IAAI;AAAA,EACT;AAAA,EACA,KAAK,CAAC,IAAI,UAAU;AAClB,OAAG,UAAU,KAAK;AAAA,EACpB;AAAA,EACA,UAAU,CAAC,IAAI,UAAU;AACvB,OAAG,WAAW;AAAA,EAChB;AAAA,EAEA,KAAK,IAAI,OAAO;AACd,OAAG,YAAY,wBAAwB,KAAK,CAAC;AAAA,EAC/C;AAAA,EAEA,UAAU,MAAM;AAAA,EAAC;AAAA,EACjB,UAAU,MAAM;AAAA,EAAC;AAAA,EACjB,YAAY,MAAM;AAAA,EAAC;AAAA,EACnB,OAAO,MAAM;AAAA,EAAC;AAChB;AACA,IAAM,6BAA6B,OAAO,KAAK,uBAAuB;AACtE,IAAM,sBAAsB,CAAC,WAAW,SAAS,QAAQ,qBAAqB,SAAS;AACrF,MAAI,CAAC,WAAW;AACd;AAAA,EACF;AAEA,QAAM,QAAQ,OAAO,IAAI,UAAU,MAAM;AAEzC,MAAI,OAAO;AACT,QAAI,oBAAoB;AACtB,YAAM,OAAO,kBAAkB,MAAM,KAAK;AAE1C,eAAS,KAAK,MAAM,OAAO,WAAW,EAAE,UAAU,WAAW,WAAW,MAAM;AAE9E,gBAAU,eAAe,WAAW,KAAK;AACzC,gBAAU,YAAY,WAAW,KAAK;AAAA,IACxC;AAEA,+BAA2B,QAAQ,SAAO;AACxC,UAAI,OAAO,SAAS;AAClB,gCAAwB,GAAG,EAAE,WAAW,QAAQ,GAAG,CAAC;AAAA,MACtD;AAAA,IACF,CAAC;AAAA,EACH;AACF;AACA,IAAM,4BAA4B,CAAC,cAAc,OAAO,QAAQ,qBAAqB,SAAS;AAE5F,QAAM,8BAA0B,sBAAQ,MAAM,2BAA2B,QAAQ,SAAO;AACtF,WAAO,cAAc,MAAM,GAAG,CAAC;AAAA,EACjC,CAAC,GAAG,CAAC,KAAK,CAAC;AACX,8BAAU,MAAM;AACd,QAAI,MAAM,QAAQ,aAAa,OAAO,GAAG;AACvC,iBAAW,aAAa,aAAa,SAAS;AAC5C,4BAAoB,WAAW,OAAO,QAAQ,kBAAkB;AAAA,MAClE;AAAA,IACF,WAAW,aAAa,SAAS;AAC/B,0BAAoB,aAAa,SAAS,OAAO,QAAQ,kBAAkB;AAAA,IAC7E;AAAA,EACF,GAAG,uBAAuB;AAC5B;AACA,IAAM,qBAAqB,CAAC,cAAc,OAAO,WAAW;AAC1D,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,gBAAgB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,8BAAU,MAAM;AACd,QAAI,MAAM,QAAQ,aAAa,OAAO,GAAG;AACvC,iBAAW,aAAa,aAAa,SAAS;AAC5C,eAAO,IAAI,UAAU,QAAQ,aAAa;AAAA,MAC5C;AAAA,IACF,WAAW,aAAa,SAAS;AAC/B,aAAO,IAAI,aAAa,QAAQ,QAAQ,aAAa;AAAA,IACvD;AAEA,WAAO,MAAM;AACX,UAAI,MAAM,QAAQ,aAAa,OAAO,GAAG;AACvC,mBAAW,aAAa,aAAa,SAAS;AAC5C,iBAAO,OAAO,UAAU,MAAM;AAAA,QAChC;AAAA,MACF,WAAW,aAAa,SAAS;AAC/B,eAAO,OAAO,aAAa,QAAQ,MAAM;AAAA,MAC3C;AAAA,IACF;AAAA,EACF,GAAG,CAAC,QAAQ,SAAS,kBAAkB,iBAAiB,qBAAqB,kBAAkB,CAAC;AAClG;AAEA,IAAM,YAAY,MAAM;AACtB,aAAO,yBAAW,aAAa;AACjC;AACA,IAAM,uBAAuB,cAAY;AACvC,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,8BAAU,MAAM;AACd,wBAAoB,IAAI,QAAQ;AAChC,WAAO,MAAM;AACX,0BAAoB,OAAO,QAAQ;AAAA,IACrC;AAAA,EACF,GAAG,CAAC,CAAC;AACP;AACA,IAAM,sBAAsB,cAAY;AACtC,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,8BAAU,MAAM;AACd,uBAAmB,IAAI,QAAQ;AAC/B,WAAO,MAAM;AACX,yBAAmB,OAAO,QAAQ;AAAA,IACpC;AAAA,EACF,GAAG,CAAC,CAAC;AACP;AAEA,IAAM,wBAAwB,CAAC,KAAK,SAAS,sBAAsB,SAAS;AAC1E,QAAM,CAAC,eAAe,gBAAgB,QAAI,uBAAS,CAAC,CAAC;AACrD,8BAAU,MAAM;AACd,UAAM,SAAS,IAAI;AAEnB,QAAI,UAAU,QAAQ,cAAc,OAAO;AACzC,uBAAiB,gCAAgC;AAAA,QAC/C,QAAQ,IAAI;AAAA,QACZ;AAAA,QACA;AAAA,MACF,CAAC,CAAC;AAAA,IACJ;AAAA,EACF,GAAG,CAAC,QAAQ,SAAS,CAAC;AACtB,SAAO;AACT;AACA,IAAM,eAAe,CAAC,UAAU,CAAC,MAAM;AACrC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,UAAU;AACd,QAAM,UAAM,qBAAO;AACnB,QAAM,oBAAgB,sBAAQ,MAAM;AAClC,WAAO,eAAe,eAAe,eAAe,CAAC,GAAG,cAAc,GAAG,OAAO,GAAG,CAAC,GAAG;AAAA,MACrF,UAAU;AAAA,IACZ,CAAC;AAAA,EACH,GAAG,CAAC,gBAAgB,OAAO,CAAC;AAC5B,QAAM,qBAAqB,sBAAsB,KAAK,aAAa;AAEnE,QAAM,mBAAe,qBAAO;AAC5B,QAAM,sBAAkB,qBAAO,MAAM;AACnC,QAAI,CAAC,aAAa,SAAS;AACzB,YAAM,OAAO,yBAAyB,OAAO;AAC7C,YAAM,YAAY,MAAM,gBAAgB,IAAI;AAC5C,mBAAa,UAAU,MAAM,aAAa,UAAU,MAAM;AAAA,IAC5D;AAEA,WAAO,aAAa;AAAA,EACtB,CAAC;AAED,8BAAU,MAAM;AACd,UAAM,YAAY,gBAAgB,QAAQ;AAC1C,iBAAa,UAAU;AAEvB,QAAI,CAAC,IAAI,SAAS;AAChB,UAAI,UAAU,IAAI,SAAS;AAAA,IAC7B;AAEA,oBAAgB,IAAI,UAAU,QAAQ,qBAAqB;AAAA,MACzD;AAAA,MACA,QAAQ,IAAI;AAAA,IACd,CAAC,CAAC;AACF,WAAO,MAAM;AACX,YAAM,gBAAgB,SAAS;AAC/B,sBAAgB,OAAO,UAAU,MAAM;AACvC,mBAAa,UAAU;AAAA,IACzB;AAAA,EACF,GAAG,CAAC,CAAC;AACL,4BAA0B,cAAc,eAAe,eAAe;AACtE,qBAAmB,cAAc,eAAe,eAAe;AAC/D,QAAM,UAAM,sBAAQ,MAAM,mBAAmB,eAAe,GAAG,CAAC,CAAC;AACjE,SAAO,CAAC,KAAK,KAAK,kBAAkB;AACtC;AAEA,IAAM,kBAAkB;AAAA,EACtB,QAAQ,CAAC,GAAG,IAAI,GAAG,GAAG,MAAM;AAAA,EAC5B,QAAQ,CAAC,GAAG,IAAI,GAAG,GAAG,MAAM,KAAK,IAAI;AAAA,EACrC,WAAW,CAAC,GAAG,IAAI,GAAG,GAAG,MAAM,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,CAAC;AAC3D;AACA,IAAM,iCAAiC,CAAC,WAAW;AAAA,EACjD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AACJ,QAAM,aAAa,UAAU,YAAY;AAEzC,YAAU,IAAI,WAAW,GAAG,WAAW,GAAG,WAAW,CAAC;AAEtD,QAAM,gBAAgB,OAAO,iBAAiB,IAAI,QAAQ,CAAC;AAC3D,QAAM,WAAW,cAAc,WAAW,SAAS;AAEnD,MAAI,WAAW,OAAO;AACpB,QAAI,QAAQ,gBAAgB,IAAI,EAAE,UAAU,UAAU,KAAK,GAAG,OAAO,UAAU,qBAAqB;AAEpG,YAAQ,UAAU,WAAW,WAAW;AAExC,QAAI,8BAA8B,oBAAoB,SAAY,OAAO;AAEzE,QAAI,oBAAoB,QAAW;AACjC,eAAS,IAAI,GAAG,IAAI,UAAU,aAAa,GAAG,KAAK;AACjD,cAAM,WAAW,UAAU,SAAS,CAAC;AACrC,cAAM,0BAA0B,SAAS,gBAAgB;AAEzD,aAAK,mBAAmB,KAAK,4BAA4B,MAAM,2BAA2B,KAAK,oBAAoB,GAAG;AACpH,wCAA8B;AAC9B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,QAAI,6BAA6B;AAC/B,eAAS,IAAI,GAAG,GAAG,CAAC,EAAE,WAAW,eAAe,SAAS,EAAE,UAAU,EAAE,eAAe,KAAK;AAE3F,gBAAU,aAAa,UAAU,IAAI;AAAA,IACvC;AAAA,EACF;AACF;AACA,IAAM,gBAAyB,mBAAK,WAAS;AAC3C,QAAM;AAAA,IACJ,WAAW,CAAC,GAAG,GAAG,CAAC;AAAA,IACnB,WAAW;AAAA,IACX,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,wBAAwB;AAAA,IACxB;AAAA,EACF,IAAI;AACJ,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,aAAS,qBAAO,IAAI;AAC1B,8BAAU,MAAM;AACd,QAAI;AAEJ,QAAI,SAAS,kBAAkB,OAAO,aAAa,QAAQ,oBAAoB,SAAS,SAAS,gBAAgB,SAAS;AAE1H,QAAI,OAAO,SAAS;AAClB,sBAAgB,IAAI,MAAM;AAAA,QACxB,QAAQ,OAAO;AAAA,QACf;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,MAAM;AACX,sBAAgB,OAAO,IAAI;AAAA,IAC7B;AAAA,EACF,GAAG,CAAC,KAAK,CAAC;AACV,SAAoB,aAAAC,QAAM,cAAc,YAAY;AAAA,IAClD,KAAK;AAAA,IACL;AAAA,EACF,CAAC;AACH,CAAC;AAED,IAAM,oBAA6B,4BAAc,MAAS;AAE1D,IAAM,gCAAgC,CAAC,QAAQ,UAAU;AACvD,MAAI,uBAAuB,uBAAuB,uBAAuB,uBAAuB,wBAAwB;AAExH,SAAO;AAAA,IACL,QAAQ;AAAA,MACN,WAAW,OAAO,UAAU;AAAA,MAC5B,UAAU,OAAO,SAAS;AAAA,MAC1B,iBAAiB,wBAAwB,OAAO,SAAS,WAAW,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB;AAAA,MAC9I,kBAAkB,wBAAwB,OAAO,UAAU,WAAW,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB;AAAA,IAClJ;AAAA,IACA,OAAO;AAAA,MACL,WAAW,MAAM,UAAU;AAAA,MAC3B,UAAU,MAAM,SAAS;AAAA,MACzB,iBAAiB,wBAAwB,MAAM,SAAS,WAAW,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB;AAAA,MAC7I,kBAAkB,wBAAwB,MAAM,UAAU,WAAW,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB;AAAA,IACjJ;AAAA,IACA,WAAW,MAAM,UAAU;AAAA,IAC3B,UAAU,MAAM,SAAS;AAAA,IACzB,iBAAiB,yBAAyB,MAAM,SAAS,WAAW,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB;AAAA,IAChJ,kBAAkB,yBAAyB,MAAM,UAAU,WAAW,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB;AAAA,EACpJ;AACF;AAEA,IAAM,eAAe,YAAY;AAC/B,MAAI,IAAI,MAAM,OAAO,yBAA2B;AAChD,QAAM,EAAE,KAAK;AACb,SAAO;AACT;AAEA,IAAM,UAAU,CAAC;AAAA,EACf,WAAW,aAAa;AAAA,EACxB,SAAS,WAAW,CAAC,GAAG,OAAO,CAAC;AAAA,EAChC;AAAA,EACA,UAAU,YAAY,IAAI;AAAA,EAC1B,QAAQ,UAAU;AAAA,EAClB;AAAA,EACA,aAAa,eAAe;AAC9B,MAAM;AACJ,QAAM,SAAS,SAAS,YAAY;AACpC,QAAM,eAAW,qBAAO;AACxB,QAAM,kBAAc,qBAAO,MAAM;AAC/B,QAAI,CAAC,SAAS,SAAS;AACrB,YAAM,QAAQ,IAAI,OAAO,MAAM,qBAAqB,QAAQ,CAAC;AAC7D,eAAS,UAAU;AAAA,IACrB;AAEA,WAAO,SAAS;AAAA,EAClB,CAAC;AACD,QAAM,kBAAkB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAChD,QAAM,iBAAiB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAC/C,QAAM,kBAAkB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAChD,QAAM,iBAAiB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAC/C,QAAM,aAAa,SAAS,MAAM,IAAI,GAAW,KAAK,CAAC;AACvD,QAAM,kBAAkB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAChD,QAAM,sBAAsB,SAAS,MAAM,oBAAI,IAAI,CAAC;AACpD,QAAM,qBAAqB,SAAS,MAAM,oBAAI,IAAI,CAAC;AAEnD,8BAAU,MAAM;AACd,UAAM,QAAQ,YAAY,QAAQ;AAClC,WAAO,MAAM;AACX,UAAI,OAAO;AACT,cAAM,KAAK;AACX,iBAAS,UAAU;AAAA,MACrB;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,8BAAU,MAAM;AACd,UAAM,QAAQ,SAAS;AAEvB,QAAI,OAAO;AACT,YAAM,UAAU,qBAAqB,QAAQ;AAAA,IAC/C;AAAA,EACF,GAAG,CAAC,QAAQ,CAAC;AACb,QAAM,UAAM,sBAAQ,MAAM,eAAe,WAAW,GAAG,CAAC,CAAC;AACzD,QAAM,kCAA8B,0BAAY,YAAU;AACxD,UAAM,QAAQ,SAAS;AAEvB,QAAI,OAAO;AACT,UAAI;AAEJ,YAAM,WAAW,MAAM,YAAY,MAAM;AACzC,YAAM,YAAY,eAAe,IAAI,MAAM;AAC3C,YAAM,gBAAgB,eAAe,IAAI,MAAM;AAC/C,YAAM,kBAAkB,aAAa,QAAQ,aAAa,SAAS,UAAU,mBAAmB,SAAS,OAAO,OAAO,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB;AACvL,YAAM,YAAY,oBAAoB,SAAY,MAAM,aAAa,eAAe,IAAI;AACxF,YAAM,WAAW,aAAa,oBAAoB,SAAY,gBAAgB,IAAI,eAAe,IAAI;AACrG,YAAM,iBAAiB,oBAAoB,SAAY,gBAAgB,IAAI,eAAe,IAAI;AAC9F,YAAM,SAAS;AAAA,QACb,UAAU;AAAA,UACR,QAAQ;AAAA,UACR,QAAQ;AAAA,UACR,OAAO;AAAA,QACT;AAAA,QACA,WAAW;AAAA,UACT,QAAQ;AAAA,UACR,QAAQ;AAAA,UACR,OAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,EACF,GAAG,CAAC,CAAC;AACL,QAAM,CAAC,aAAa,QAAI,uBAAS;AAAA,IAC/B,eAAe,CAAC;AAAA,IAChB,aAAa;AAAA,EACf,CAAC;AACD,QAAM,WAAO,0BAAY,QAAM;AAC7B,UAAM,QAAQ,SAAS;AACvB,QAAI,CAAC;AAAO;AAIZ,UAAM,mBAAmB,cAAc;AAMvC,UAAM,eAAe,UAAU,MAAM,IAAI,GAAG,GAAG;AAE/C,UAAM,YAAY,MAAM;AAEtB,YAAM,iBAAiB,UAAQ;AAC7B,wBAAgB,QAAQ,oBAAkB;AACxC,yCAA+B,MAAM,cAAc;AAAA,QACrD,CAAC;AAAA,MACH,CAAC;AAED,0BAAoB,QAAQ,cAAY;AACtC,iBAAS,GAAG;AAAA,MACd,CAAC;AACD,YAAM,KAAK,UAAU;AAErB,yBAAmB,QAAQ,cAAY;AACrC,iBAAS,GAAG;AAAA,MACd,CAAC;AAAA,IACH;AAEA,QAAI,kBAAkB;AACpB,YAAM,WAAW;AACjB,gBAAU;AAAA,IACZ,OAAO;AACL,YAAM,WAAW;AAGjB,oBAAc,eAAe;AAE7B,aAAO,cAAc,eAAe,WAAW;AAG7C,YAAI,cAAc;AAChB,wBAAc,gBAAgB,CAAC;AAC/B,gBAAM,iBAAiB,UAAQ;AAC7B,0BAAc,cAAc,KAAK,MAAM,IAAI;AAAA,cACzC,UAAU,KAAK,YAAY;AAAA,cAC3B,UAAU,KAAK,SAAS;AAAA,YAC1B;AAAA,UACF,CAAC;AAAA,QACH;AAEA,kBAAU;AACV,sBAAc,eAAe;AAAA,MAC/B;AAAA,IACF;AAEA,UAAM,qBAAqB,oBAAoB,CAAC,gBAAgB,UAAU,IAAI,cAAc,cAAc;AAE1G,oBAAgB,QAAQ,CAAC,OAAO,WAAW;AACzC,YAAM,YAAY,MAAM,aAAa,MAAM;AAC3C,YAAM,SAAS,gBAAgB,IAAI,MAAM;AAEzC,UAAI,WAAW,QAAQ,WAAW,UAAU,OAAO,WAAW,WAAW,QAAQ,WAAW,UAAU,OAAO,QAAQ;AACnH,YAAI,UAAU,WAAW,KAAK,CAAC,MAAM,YAAY;AAC/C,cAAI;AAEJ,qBAAW,QAAQ,WAAW,SAAS,UAAU,kBAAkB,OAAO,aAAa,QAAQ,oBAAoB,SAAS,SAAS,gBAAgB,KAAK,MAAM;AAAA,QAClK;AAEA,YAAI,CAAC,UAAU,WAAW,KAAK,MAAM,YAAY;AAC/C,cAAI;AAEJ,qBAAW,QAAQ,WAAW,SAAS,UAAU,iBAAiB,OAAO,YAAY,QAAQ,mBAAmB,SAAS,SAAS,eAAe,KAAK,MAAM;AAAA,QAC9J;AAEA,cAAM,aAAa,UAAU,WAAW;AAAA,MAC1C;AAEA,UAAI,CAAC,aAAa,UAAU,WAAW,KAAK,CAAC,MAAM,WAAW;AAC5D;AAAA,MACF;AAGA,UAAI,IAAI,UAAU,YAAY;AAC9B,UAAI,IAAI,UAAU,SAAS;AAC3B,UAAI,gBAAgB,cAAc,cAAc,MAAM;AAEtD,UAAI,eAAe;AAEjB,iBAAS,QAAQ,cAAc,UAAU,6BAA6B,cAAc,QAAQ,GAAG,MAAM,KAAK,EAAE,YAAY,MAAM,mBAAmB,EAAE,UAAU,WAAW,WAAW,MAAM;AAGzL,YAAI,EAAE,MAAM,kBAAkB,gBAAgB;AAC5C,gBAAM,OAAO,SAAS,KAAK,SAAS;AACpC,gBAAM,OAAO,WAAW,KAAK,SAAS;AAAA,QACxC;AAAA,MACF;AAGA,eAAS,QAAQ,GAAG,6BAA6B,CAAC,GAAG,MAAM,KAAK,EAAE,YAAY,MAAM,mBAAmB,EAAE,UAAU,WAAW,WAAW,MAAM;AAE/I,UAAI,MAAM,kBAAkB,eAAe;AACzC,cAAM,UAAU,QAAQ;AACxB,cAAM,OAAO,eAAe,cAAc;AAAA,MAC5C,OAAO;AAEL,cAAM,OAAO,SAAS,KAAK,WAAW,kBAAkB;AACxD,cAAM,OAAO,WAAW,MAAM,WAAW,kBAAkB;AAAA,MAC7D;AAAA,IACF,CAAC;AACD,eAAW,qBAAqB,CAAC,SAAS,SAAS,YAAY;AAC7D,YAAM,UAAU,4BAA4B,OAAO;AACnD,YAAM,UAAU,4BAA4B,OAAO;AAEnD,UAAI,EAAE,YAAY,QAAQ,YAAY,UAAU,QAAQ,SAAS,WAAW,EAAE,YAAY,QAAQ,YAAY,UAAU,QAAQ,SAAS,SAAS;AAChJ;AAAA,MACF;AAEA,YAAM,oBAAoB,8BAA8B,SAAS,OAAO;AACxE,YAAM,oBAAoB,8BAA8B,SAAS,OAAO;AAExE,UAAI,SAAS;AACX,cAAM,YAAY,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,CAAC,UAAU,YAAY;AACzF,cAAI,uBAAuB,wBAAwB,uBAAuB,wBAAwB,uBAAuB,wBAAwB,uBAAuB;AAGxK,WAAC,wBAAwB,QAAQ,UAAU,YAAY,QAAQ,0BAA0B,SAAS,UAAU,yBAAyB,sBAAsB,sBAAsB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,uBAAuB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,YACjV;AAAA,YACA;AAAA,UACF,CAAC,CAAC;AACF,WAAC,wBAAwB,QAAQ,UAAU,YAAY,QAAQ,0BAA0B,SAAS,UAAU,yBAAyB,sBAAsB,sBAAsB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,uBAAuB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,YACjV;AAAA,YACA;AAAA,UACF,CAAC,CAAC;AAGF,WAAC,wBAAwB,QAAQ,SAAS,YAAY,QAAQ,0BAA0B,SAAS,UAAU,yBAAyB,sBAAsB,sBAAsB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,uBAAuB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,YAChV;AAAA,YACA;AAAA,UACF,CAAC,CAAC;AACF,WAAC,wBAAwB,QAAQ,SAAS,YAAY,QAAQ,0BAA0B,SAAS,UAAU,yBAAyB,sBAAsB,sBAAsB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,uBAAuB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,YAChV;AAAA,YACA;AAAA,UACF,CAAC,CAAC;AAAA,QACJ,CAAC;AAAA,MACH,OAAO;AACL,YAAI,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB;AAE5K,SAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,qBAAqB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAC7S,SAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,qBAAqB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAC7S,SAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,qBAAqB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAC5S,SAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,qBAAqB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAAA,MAC9S;AAGA,UAAI,SAAS;AACX,YAAI,MAAM,iBAAiB,QAAQ,SAAS,QAAQ,QAAQ,SAAS,MAAM,GAAG;AAC5E,cAAI,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB;AAE5K,WAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,yBAAyB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AACjT,WAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,yBAAyB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AACjT,WAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,yBAAyB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAChT,WAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,yBAAyB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAAA,QAClT;AAAA,MACF,OAAO;AACL,YAAI,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB;AAE5K,SAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,wBAAwB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAChT,SAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,wBAAwB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAChT,SAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,wBAAwB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAC/S,SAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,yBAAyB,uBAAuB,wBAAwB,QAAQ,2BAA2B,SAAS,SAAS,uBAAuB,KAAK,wBAAwB,iBAAiB;AAAA,MACjT;AAAA,IACF,CAAC;AACD,eAAW,wBAAwB,WAAS;AAC1C,UAAI,wBAAwB,yBAAyB,wBAAwB,yBAAyB,wBAAwB,yBAAyB,wBAAwB;AAE/K,YAAM,UAAU,4BAA4B,MAAM,UAAU,CAAC;AAC7D,YAAM,UAAU,4BAA4B,MAAM,UAAU,CAAC;AAE7D,UAAI,EAAE,YAAY,QAAQ,YAAY,UAAU,QAAQ,SAAS,WAAW,EAAE,YAAY,QAAQ,YAAY,UAAU,QAAQ,SAAS,SAAS;AAChJ;AAAA,MACF;AAEA,YAAM,oBAAoB,8BAA8B,SAAS,OAAO;AACxE,YAAM,oBAAoB,8BAA8B,SAAS,OAAO;AACxE,OAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,0BAA0B,uBAAuB,oBAAoB,QAAQ,4BAA4B,SAAS,SAAS,wBAAwB,KAAK,wBAAwB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,QACtV,YAAY,MAAM,WAAW;AAAA,QAC7B,qBAAqB,MAAM,oBAAoB;AAAA,QAC/C,mBAAmB,MAAM,kBAAkB;AAAA,QAC3C,mBAAmB,MAAM,kBAAkB;AAAA,MAC7C,CAAC,CAAC;AACF,OAAC,yBAAyB,QAAQ,UAAU,YAAY,QAAQ,2BAA2B,SAAS,UAAU,0BAA0B,uBAAuB,oBAAoB,QAAQ,4BAA4B,SAAS,SAAS,wBAAwB,KAAK,wBAAwB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,QACtV,YAAY,MAAM,WAAW;AAAA,QAC7B,qBAAqB,MAAM,oBAAoB;AAAA,QAC/C,mBAAmB,MAAM,kBAAkB;AAAA,QAC3C,mBAAmB,MAAM,kBAAkB;AAAA,MAC7C,CAAC,CAAC;AACF,OAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,0BAA0B,uBAAuB,oBAAoB,QAAQ,4BAA4B,SAAS,SAAS,wBAAwB,KAAK,wBAAwB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,QACrV,YAAY,MAAM,WAAW;AAAA,QAC7B,qBAAqB,MAAM,oBAAoB;AAAA,QAC/C,mBAAmB,MAAM,kBAAkB;AAAA,QAC3C,mBAAmB,MAAM,kBAAkB;AAAA,MAC7C,CAAC,CAAC;AACF,OAAC,yBAAyB,QAAQ,SAAS,YAAY,QAAQ,2BAA2B,SAAS,UAAU,0BAA0B,uBAAuB,oBAAoB,QAAQ,4BAA4B,SAAS,SAAS,wBAAwB,KAAK,wBAAwB,eAAe,eAAe,CAAC,GAAG,iBAAiB,GAAG,CAAC,GAAG;AAAA,QACrV,YAAY,MAAM,WAAW;AAAA,QAC7B,qBAAqB,MAAM,oBAAoB;AAAA,QAC/C,mBAAmB,MAAM,kBAAkB;AAAA,QAC3C,mBAAmB,MAAM,kBAAkB;AAAA,MAC7C,CAAC,CAAC;AAAA,IACJ,CAAC;AAAA,EACH,GAAG,CAAC,SAAS,WAAW,YAAY,CAAC;AACrC,WAAS,CAAC,GAAG,OAAO;AAClB,QAAI,CAAC;AAAS,WAAK,EAAE;AAAA,EACvB,GAAG,cAAc;AACjB,QAAM,cAAU,sBAAQ,OAAO;AAAA,IAC7B;AAAA,IACA,OAAO;AAAA,IACP,gBAAgB;AAAA,MACd,WAAW;AAAA,MACX,SAAS;AAAA,IACX;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU;AAAA,IACV;AAAA,EACF,IAAI,CAAC,SAAS,IAAI,CAAC;AACnB,SAAoB,aAAAA,QAAM,cAAc,cAAc,UAAU;AAAA,IAC9D,OAAO;AAAA,EACT,GAAG,QAAQ;AACb;AAEA,SAAS,WAAW;AAClB,aAAW,OAAO,SAAS,OAAO,OAAO,KAAK,IAAI,SAAU,QAAQ;AAClE,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,UAAI,SAAS,UAAU,CAAC;AAExB,eAAS,OAAO,QAAQ;AACtB,YAAI,OAAO,UAAU,eAAe,KAAK,QAAQ,GAAG,GAAG;AACrD,iBAAO,GAAG,IAAI,OAAO,GAAG;AAAA,QAC1B;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACA,SAAO,SAAS,MAAM,MAAM,SAAS;AACvC;AAEA,SAAS,8BAA8B,QAAQ,UAAU;AACvD,MAAI,UAAU;AAAM,WAAO,CAAC;AAC5B,MAAI,SAAS,CAAC;AACd,MAAI,aAAa,OAAO,KAAK,MAAM;AACnC,MAAI,KAAK;AAET,OAAK,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACtC,UAAM,WAAW,CAAC;AAClB,QAAI,SAAS,QAAQ,GAAG,KAAK;AAAG;AAChC,WAAO,GAAG,IAAI,OAAO,GAAG;AAAA,EAC1B;AAEA,SAAO;AACT;AAEA,SAAS,yBAAyB,QAAQ,UAAU;AAClD,MAAI,UAAU;AAAM,WAAO,CAAC;AAC5B,MAAI,SAAS,8BAA8B,QAAQ,QAAQ;AAC3D,MAAI,KAAK;AAET,MAAI,OAAO,uBAAuB;AAChC,QAAI,mBAAmB,OAAO,sBAAsB,MAAM;AAE1D,SAAK,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK;AAC5C,YAAM,iBAAiB,CAAC;AACxB,UAAI,SAAS,QAAQ,GAAG,KAAK;AAAG;AAChC,UAAI,CAAC,OAAO,UAAU,qBAAqB,KAAK,QAAQ,GAAG;AAAG;AAC9D,aAAO,GAAG,IAAI,OAAO,GAAG;AAAA,IAC1B;AAAA,EACF;AAEA,SAAO;AACT;AAGA,IAAM,kBAA2B,mBAAmB,aAAAA,QAAM,WAAW,CAAC,OAAO,iBAAiB;AAC5F,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,UAAU;AACd,QAAM,mBAAmB,oBAAoB;AAC7C,QAAM,UAAM,qBAAO,IAAI;AACvB,QAAM,mBAAe,sBAAQ,MAAM;AACjC,QAAI,iBAAiB,MAAM;AACzB,aAAO;AAAA,IACT;AAEA,UAAM,SAAsB,aAAAA,QAAM,UAAU;AAC5C,WAAO,UAAU,CAAC;AAClB,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACL,8BAAU,MAAM;AACd,UAAM,SAAS,IAAI;AACnB,UAAM,aAAa,OAAO,cAAc,IAAI,QAAQ,CAAC;AACrD,UAAM,YAAY,CAAC;AAEnB,QAAI,oBAAoB,QAAQ,iBAAiB,KAAK;AACpD,uBAAiB,IAAI,QAAQ,CAAC,MAAM,UAAU;AAC5C,YAAI,uBAAuB;AAE3B,YAAI,gBAAgB;AAEpB,YAAI,YAAY,iBAAiB,WAAW,qBAAqB,QAAQ,qBAAqB,WAAW,wBAAwB,iBAAiB,aAAa,QAAQ,0BAA0B,WAAW,yBAAyB,sBAAsB,YAAY,QAAQ,2BAA2B,UAAU,uBAAuB,KAAK,GAAG;AACjV,0BAAgB,cAAc,MAAM,EAAE,SAAS,qBAAqB,iBAAiB,QAAQ,OAAO,KAAK,CAAC,CAAC;AAAA,QAC7G;AAEA,cAAM,WAAW,0BAA0B,OAAO,OAAO,eAAe,KAAK,IAAI,CAAC;AAClF,uBAAe,IAAI,SAAS,QAAQ,oBAAoB,UAAU,QAAQ,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,IAAI,OAAO,CAAC;AAC3K,kBAAU,KAAK,QAAQ;AAAA,MACzB,CAAC;AAAA,IACH,OAAO;AACL,YAAM,WAAW,0BAA0B,OAAO,OAAO,YAAY,qBAAqB,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,KAAK,IAAI,CAAC;AACzL,qBAAe,IAAI,SAAS,QAAQ,oBAAoB,UAAU,QAAQ,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,IAAI,OAAO,CAAC;AAC3K,gBAAU,KAAK,QAAQ;AAAA,IACzB;AAEA,iBAAa,UAAU;AACvB,WAAO,MAAM;AACX,gBAAU,QAAQ,cAAY;AAC5B,cAAM,eAAe,QAAQ;AAAA,MAC/B,CAAC;AAAA,IACH;AAAA,EACF,GAAG,CAAC,CAAC;AACL,QAAM,kBAAc,sBAAQ,MAAM;AAChC,WAAO,eAAe,eAAe,CAAC,GAAG,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,OAAO,GAAG,KAAK;AAAA,EAC/I,GAAG,CAAC,OAAO,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,OAAO,CAAC;AACxG,2BAAyB,cAAc,aAAa,cAAc;AAClE,oBAAkB,cAAc,aAAa,cAAc;AAC3D,SAAoB,aAAAA,QAAM,cAAc,YAAY;AAAA,IAClD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAAG,QAAQ;AACb,CAAC,CAAC;AACF,IAAM,iBAA8B,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAQ;AACnE,SAAoB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,IACvE,OAAO;AAAA,IACP;AAAA,EACF,CAAC,CAAC;AACJ,CAAC;AACD,IAAM,sBAAmC,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAQ;AACxE,SAAoB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,IACvE,OAAO;AAAA,IACP;AAAA,EACF,CAAC,CAAC;AACJ,CAAC;AACD,IAAM,eAA4B,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAQ;AACjE,SAAoB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,IACvE,OAAO;AAAA,IACP;AAAA,EACF,CAAC,CAAC;AACJ,CAAC;AACD,IAAM,kBAA+B,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAQ;AACpE,SAAoB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,IACvE,OAAO;AAAA,IACP;AAAA,EACF,CAAC,CAAC;AACJ,CAAC;AACD,IAAM,sBAAmC,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAQ;AACxE,SAAoB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,IACvE,OAAO;AAAA,IACP;AAAA,EACF,CAAC,CAAC;AACJ,CAAC;AACD,IAAM,kBAA+B,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAQ;AACpE,SAAoB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,IACvE,OAAO;AAAA,IACP;AAAA,EACF,CAAC,CAAC;AACJ,CAAC;AACD,IAAM,eAA4B,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAQ;AACjE,SAAoB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,IACvE,OAAO;AAAA,IACP;AAAA,EACF,CAAC,CAAC;AACJ,CAAC;AACD,IAAM,mBAAgC,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAQ;AACrE,SAAoB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,IACvE,OAAO;AAAA,IACP;AAAA,EACF,CAAC,CAAC;AACJ,CAAC;AACD,IAAM,qBAAkC,aAAAA,QAAM,WAAW,CAAC,OAAO,QAAQ;AACvE,SAAoB,aAAAA,QAAM,cAAc,aAAa,SAAS,CAAC,GAAG,OAAO;AAAA,IACvE,OAAO;AAAA,IACP;AAAA,EACF,CAAC,CAAC;AACJ,CAAC;AACD,eAAe,cAAc;AAC7B,oBAAoB,cAAc;AAClC,aAAa,cAAc;AAC3B,gBAAgB,cAAc;AAC9B,oBAAoB,cAAc;AAClC,gBAAgB,cAAc;AAC9B,aAAa,cAAc;AAC3B,iBAAiB,cAAc;AAC/B,mBAAmB,cAAc;AAEjC,IAAM,cAAc,CAAC,YAAY,QAAQ,YAAY,YAAY,SAAS,YAAY;AACtF,IAAM,uBAAgC,4BAAc,MAAS;AAC7D,IAAM,sBAAsB,UAAM,yBAAW,gBAAgB;AAC7D,IAAM,gBAAyB,uBAAmB,yBAAW,CAAC,OAAO,QAAQ;AAC3E,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,OACE,cAAc,yBAAyB,OAAO,WAAW;AAE/D,QAAM,CAAC,QAAQ,KAAK,kBAAkB,IAAI,aAAa,KAAK;AAC5D,wCAAoB,KAAK,MAAM,GAAG;AAClC,QAAM,mBAAe,sBAAQ,OAAO;AAAA,IAClC,KAAK;AAAA,IACL;AAAA,IACA,SAAS;AAAA,EACX,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC;AACxB,SAAoB,aAAAA,QAAM,cAAc,iBAAiB,UAAU;AAAA,IACjE,OAAO;AAAA,EACT,GAAgB,aAAAA,QAAM,cAAc,YAAY,SAAS;AAAA,IACvD,KAAK;AAAA,EACP,GAAG,aAAa;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC,GAAG,UAAU,mBAAmB,IAAI,CAAC,eAAe,UAAuB,aAAAA,QAAM,cAAc,aAAa,SAAS;AAAA,IACpH,KAAK;AAAA,EACP,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC;AACF,UAAU,cAAc;AAExB,IAAM,mBAA4B,mBAAK,WAAS;AAC9C,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI,UAAU;AACd,QAAM,aAAS,qBAAO,IAAI;AAC1B,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,oBAAoB;AACxB,QAAM,oBAAgB,sBAAQ,MAAM;AAClC,WAAO,eAAe,eAAe,eAAe,CAAC,GAAG,cAAc,GAAG,OAAO,GAAG,CAAC,GAAG;AAAA,MACrF,UAAU;AAAA,MACV,WAAW;AAAA,IACb,CAAC;AAAA,EACH,GAAG,CAAC,gBAAgB,OAAO,CAAC;AAC5B,QAAM,qBAAqB,sBAAsB,QAAQ,eAAe,KAAK;AAC7E,SAAoB,aAAAA,QAAM,cAAc,YAAY;AAAA,IAClD,KAAK;AAAA,IACL,UAAU;AAAA,MACR,cAAc;AAAA,IAChB;AAAA,EACF,GAAG,UAAU,mBAAmB,IAAI,CAAC,eAAe,UAAuB,aAAAA,QAAM,cAAc,aAAa,SAAS;AAAA,IACnH,KAAK;AAAA,EACP,GAAG,aAAa,CAAC,CAAC,CAAC;AACrB,CAAC;AACD,aAAa,cAAc;AAE3B,SAAS,UAAU,MAAM,MAAM;AAC7B,MAAI;AAEJ,MAAI,KAAK,SAAS,KAAK,MAAM;AAC3B,WAAO;AAAA,EACT;AAEA,WAAS,CAAC,KAAK,GAAG,KAAK,MAAM;AAC3B,cAAU,KAAK,IAAI,GAAG;AAEtB,QAAI,YAAY,OAAO,YAAY,UAAa,CAAC,KAAK,IAAI,GAAG,GAAG;AAC9D,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,kBAAkB,WAAS;AAC/B,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,SAAS;AACb,QAAM,UAAM,qBAAO,IAAI;AACvB,QAAM,oBAAgB,qBAAO;AAC7B,QAAM,QAAQ,MAAM,WAAW,IAAI,MAAW;AAC9C,8BAAU,MAAM;AACd,QAAI,IAAI,SAAS;AACf,oBAAc,UAAU,IAAI,oBAAoB,IAAI,SAAS,MAAM,OAAO,KAAK;AAC/E,oBAAc,QAAQ,gBAAgB;AACtC,YAAM,IAAI,cAAc,OAAO;AAAA,IACjC;AAEA,WAAO,MAAM;AACX,UAAI,cAAc,SAAS;AACzB,cAAM,OAAO,cAAc,OAAO;AAAA,MACpC;AAAA,IACF;AAAA,EACF,GAAG,CAAC,KAAK,CAAC;AACV,WAAS,MAAM;AACb,QAAI,IAAI,SAAS;AACf,UAAI;AAEJ,YAAM,gBAAgB,MAAM,OAAO,iBAAiB,QAAQ;AAC5D,UAAI,QAAQ,SAAS,KAAK,aAAa;AACvC,OAAC,wBAAwB,cAAc,aAAa,QAAQ,0BAA0B,SAAS,SAAS,sBAAsB,OAAO;AAAA,IACvI;AAAA,EACF,CAAC;AACD,SAAoB,aAAAA,QAAM,cAAc,QAAQ;AAAA,IAC9C;AAAA,IACA,UAAU,MAAM,OAAO;AAAA,IACvB,eAAe;AAAA,EACjB,GAAgB,aAAAA,QAAM,cAAc,kBAAkB;AAAA,IACpD,MAAM,CAAC,KAAK,GAAG,CAAC;AAAA,EAClB,CAAC,GAAgB,aAAAA,QAAM,cAAc,qBAAqB;AAAA,IACxD;AAAA,IACA,WAAW;AAAA,EACb,CAAC,CAAC;AACJ;AAEA,IAAM,YAAqB,mBAAK,MAAM;AACpC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI,UAAU;AACd,QAAM,UAAM,qBAAO,IAAI;AACvB,QAAM,CAAC,YAAY,aAAa,QAAI,uBAAS,CAAC,CAAC;AAC/C,QAAM,cAAU,qBAAO,oBAAI,IAAI,CAAC;AAChC,WAAS,MAAM;AACb,UAAM,OAAO,IAAI;AACjB,QAAI,CAAC;AAAM;AACX,UAAM,UAAU,MAAM,YAAY;AAClC,SAAK,SAAS,aAAa,YAAY,IAAI,gBAAgB,QAAQ,UAAU,CAAC,CAAC;AAC/E,SAAK,SAAS,aAAa,SAAS,IAAI,gBAAgB,QAAQ,QAAQ,CAAC,CAAC;AAE1E,QAAI,CAAC,UAAU,QAAQ,SAAS,eAAe,GAAG;AAChD,oBAAc,CAAC,GAAG,gBAAgB,OAAO,CAAC,CAAC;AAC3C,cAAQ,UAAU,IAAI,IAAI,eAAe;AAAA,IAC3C;AAAA,EACF,CAAC;AACD,SAAoB,aAAAA,QAAM,cAAc,SAAS,MAAmB,aAAAA,QAAM,cAAc,gBAAgB;AAAA,IACtG;AAAA,IACA,eAAe;AAAA,EACjB,GAAgB,aAAAA,QAAM,cAAc,qBAAqB;AAAA,IACvD,OAAO;AAAA,IACP,cAAc;AAAA,EAChB,CAAC,GAAgB,aAAAA,QAAM,cAAc,kBAAkB,IAAI,CAAC,GAAG,WAAW,IAAI,CAAC,WAAW,MAAmB,aAAAA,QAAM,cAAc,iBAAiB,SAAS;AAAA,IACzJ,KAAK,UAAU,OAAO;AAAA,EACxB,GAAG,SAAS,CAAC,CAAC,CAAC;AACjB,CAAC;AAED,IAAM,YAAY,CAAC,aAAa,aAAa,UAAU;AACvD,IAAM,2BAAoC,yBAAW,CAAC,OAAO,QAAQ;AACnE,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,UAAU;AACd,QAAM,aAAS,qBAAO,IAAI;AAE1B,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,OACE,UAAU,yBAAyB,OAAO,SAAS;AAEzD,QAAM,mBAAe,qBAAO,CAAC,CAAC;AAC9B,QAAM,oBAAgB,qBAAO,CAAC,CAAC;AAC/B,QAAM,yBAAqB,qBAAO,MAAM;AACtC,QAAI,CAAC,aAAa,SAAS;AACzB,mBAAa,UAAU,CAAC;AAAA,IAC1B;AAEA,WAAO,aAAa;AAAA,EACtB,CAAC;AACD,QAAM,oBAAgB,sBAAQ,MAAM;AAClC,WAAO,eAAe,eAAe,CAAC,GAAG,cAAc,GAAG,OAAO;AAAA,EACnE,GAAG,CAAC,gBAAgB,OAAO,CAAC;AAC5B,QAAM,qBAAqB,sBAAsB,QAAQ,aAAa;AACtE,oCAAgB,MAAM;AACpB,WAAO,QAAQ,kBAAkB,MAAM,KAAK;AAC5C,UAAM,YAAY,mBAAmB,QAAQ;AAC7C,UAAM,gBAAgB,OAAO,QAAQ,YAAY,MAAM,EAAE,OAAO;AAChE,WAAO,QAAQ,gBAAgB,UAAQ;AACrC,UAAI,gBAAgB,eAAe;AACjC,aAAK,eAAe,SAAS,gBAAgB;AAC7C,cAAM,aAAa,KAAK,cAAc,MAAM;AAE5C,iBAAS,QAAQ,GAAG,QAAQ,KAAK,OAAO,SAAS;AAC/C,cAAI;AAEJ,gBAAM,OAAO,yBAAyB,KAAK;AAC3C,gBAAM,YAAY,MAAM,gBAAgB,IAAI;AAC5C,wBAAc,QAAQ,KAAK,SAAS;AACpC,gBAAM,UAAU,kBAAkB,QAAQ,YAAY,QAAQ,oBAAoB,SAAS,SAAS,gBAAgB,KAAK,MAAM,CAAC,GAAG,GAAG,CAAC;AACvI,gBAAM,gBAAgB,WAAW,MAAM,EAAE,SAAS,qBAAqB,KAAK,CAAC;AAC7E,0BAAgB,IAAI,UAAU,QAAQ,qBAAqB;AAAA,YACzD;AAAA,YACA,QAAQ;AAAA,YACR,WAAW,YAAU,KAAK,YAAY,OAAO,MAAM;AAAA,YACnD,WAAW,YAAU;AACnB,mBAAK,YAAY,OAAO,MAAM;AAC9B,qBAAO;AAAA,YACT;AAAA,YACA,YAAY;AAAA,UACd,CAAC,CAAC;AACF,gBAAM,CAAC,GAAG,GAAG,CAAC,KAAK,cAAc,QAAQ,cAAc,SAAS,SAAS,UAAU,KAAK,MAAM,CAAC,GAAG,GAAG,CAAC;AACtG,gBAAM,CAAC,IAAI,IAAI,EAAE,KAAK,cAAc,QAAQ,cAAc,SAAS,SAAS,UAAU,KAAK,MAAM,CAAC,GAAG,GAAG,CAAC;AAEzG,oBAAU,SAAS,IAAI,GAAG,GAAG,CAAC;AAE9B,oBAAU,SAAS,IAAI,IAAI,IAAI,EAAE;AAEjC,oBAAU,aAAa,aAAa;AAEpC,eAAK,YAAY,OAAO,UAAU,MAAM;AACxC,oBAAU,eAAe,UAAU,UAAU,KAAK;AAClD,oBAAU,YAAY,UAAU,YAAY,KAAK;AACjD,gBAAMC,OAAM,mBAAmB;AAAA,YAC7B,UAAU;AACR,qBAAO;AAAA,YACT;AAAA,UAEF,CAAC;AACD,oBAAU,KAAK;AAAA,YACb;AAAA,YACA,KAAAA;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,CAAC;AACD,WAAO,MAAM;AACX,gBAAU,QAAQ,QAAM;AACtB,cAAM,gBAAgB,GAAG,SAAS;AAClC,wBAAgB,OAAO,GAAG,UAAU,MAAM;AAAA,MAC5C,CAAC;AACD,oBAAc,UAAU,CAAC;AACzB,mBAAa,UAAU,CAAC;AAAA,IAC1B;AAAA,EACF,GAAG,CAAC,CAAC;AACL,QAAM,UAAM,sBAAQ,MAAM,8BAA8B,kBAAkB,GAAG,CAAC,CAAC;AAC/E,wCAAoB,KAAK,MAAM,GAAG;AAClC,4BAA0B,eAAe,eAAe,iBAAiB,KAAK;AAC9E,qBAAmB,eAAe,eAAe,eAAe;AAChE,QAAM,mBAAe,sBAAQ,MAAM;AACjC,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF,GAAG,CAAC,KAAK,aAAa,CAAC;AACvB,SAAoB,aAAAD,QAAM,cAAc,iBAAiB,UAAU;AAAA,IACjE,OAAO;AAAA,EACT,GAAgB,aAAAA,QAAM,cAAc,YAAY;AAAA,IAC9C,KAAK;AAAA,EACP,GAAG,MAAM,UAAU,mBAAmB,IAAI,CAAC,eAAe,UAAuB,aAAAA,QAAM,cAAc,aAAa,SAAS;AAAA,IACzH,KAAK;AAAA,EACP,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC;AACD,qBAAqB,cAAc;AAEnC,IAAM,kBAAkB,CAAC,OAAO,OAAO,WAAW;AAChD,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,eAAW,qBAAO;AACxB,QAAM,kBAAc,qBAAO,MAAM;AAC/B,QAAI,CAAC,SAAS,SAAS;AACrB,UAAI;AACJ,UAAI;AAEJ,UAAI,aAAa,SAAS,MAAM,WAAW,aAAa,SAAS,MAAM,SAAS;AAC9E,cAAM,MAAM,aAAa,MAAM,QAAQ,MAAM;AAC7C,cAAM,MAAM,aAAa,MAAM,QAAQ,MAAM;AAC7C,cAAM,WAAW,MAAM,mBAAmB,QAAQ,KAAK,GAAG;AAC1D,iBAAS,UAAU;AAAA,MACrB;AAAA,IACF;AAEA,WAAO,SAAS;AAAA,EAClB,CAAC;AACD,8BAAU,MAAM;AACd,UAAM,QAAQ,YAAY,QAAQ;AAClC,WAAO,MAAM;AACX,UAAI,OAAO;AACT,cAAM,mBAAmB,KAAK;AAC9B,iBAAS,UAAU;AAAA,MACrB;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAC;AACL,QAAM,UAAM,sBAAQ,MAAM,eAAe,WAAW,GAAG,CAAC,CAAC;AACzD,SAAO;AACT;AAQA,IAAM,gBAAgB,CAAC,OAAO,OAAO,CAAC,aAAa,iBAAiB,aAAa,eAAe,MAAM;AACpG,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,SAAO,gBAAgB,OAAO,OAAO,OAAO,UAAU,MAAM,qBAAqB,WAAW,GAAG,cAAc,iBAAiB,CAAC,KAAK,KAAK,KAAK,GAAG,CAAC,GAAG,qBAAqB,WAAW,GAAG,cAAc,iBAAiB,CAAC,KAAK,KAAK,KAAK,GAAG,CAAC,CAAC,CAAC;AAC/O;AAQA,IAAM,oBAAoB,CAAC,OAAO,OAAO,CAAC,aAAa,WAAW,MAAM;AACtE,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,SAAO,gBAAgB,OAAO,OAAO,OAAO,UAAU,UAAU,qBAAqB,WAAW,GAAG,qBAAqB,WAAW,CAAC,CAAC;AACvI;AAOA,IAAM,mBAAmB,CAAC,OAAO,OAAO,CAAC,aAAa,aAAa,MAAM,MAAM,MAAM;AACnF,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,SAAS,OAAO,UAAU,SAAS,qBAAqB,WAAW,GAAG,qBAAqB,WAAW,GAAG,qBAAqB,IAAI,CAAC;AAEzI,MAAI,QAAQ;AACV,WAAO,gBAAgB;AACvB,WAAO,SAAS;AAAA,EAClB;AAEA,SAAO,gBAAgB,OAAO,OAAO,MAAM;AAC7C;AAOA,IAAM,oBAAoB,CAAC,OAAO,OAAO,CAAC,aAAa,aAAa,MAAM,MAAM,MAAM;AACpF,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,UAAU;AACd,QAAM,SAAS,OAAO,UAAU,UAAU,qBAAqB,WAAW,GAAG,qBAAqB,WAAW,GAAG,qBAAqB,IAAI,CAAC;AAE1I,MAAI,QAAQ;AACV,WAAO,gBAAgB;AACvB,WAAO,SAAS;AAAA,EAClB;AAEA,SAAO,gBAAgB,OAAO,OAAO,MAAM;AAC7C;AAkCA,IAAM,oBAAoB,CAAC,aAAa,aAAa,QAAQ,WAAW,KAAK,OAAO,YAAY,SAAY,QAAQ,OAAO,IAAI;AAE/H,IAAM,UAAU,YAAU,CAAC,MAAM,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,UAAU,MAAM,KAAK,OAAO,CAAC;",
  "names": ["entry", "deepEqual", "deepEqual", "React", "api"]
}
